You are an AI code generator responsible for implementing a web application. You will be required to make complex fixes to features.

Your task is to systematically implement features.

First, carefully review the following inputs:
<file_contents>


===== ./jest.config.js =====

export default {
  projects: [
    {
      displayName: "server",
      testEnvironment: "node",
      transform: {
        "^.+\\.[tj]s$": "babel-jest",
      },
      testMatch: [
        "<rootDir>/tests/unit/**/*.test.js",
        "<rootDir>/tests/integration/**/*.test.js",
      ],
    },
    {
      displayName: "client",
      testEnvironment: "jsdom",
      transform: {
        "^.+\\.[tj]s$": "babel-jest",
      },
      testMatch: ["<rootDir>/tests/client/**/*.test.js"],
      setupFiles: ["jest-canvas-mock"],
    },
  ],
};


===== ./.env.test =====

PORT=3000
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgrespassword
DB_NAME=board_game_prototyping_test
DB_USER=admin
DB_PASSWORD=test1234
DB_HOST=db
DB_PORT=5432
DB_SSL=false
JWT_SECRET=your_jwt_secret
NODE_ENV=test


===== ./README.md =====

# Board Game Prototyping App

## Overview

An interactive board game prototyping environment that allows multiple users to collaborate in real time. Users can connect to a shared session and interact with a full-screen canvas containing various virtual board game elements.

## Features

- **Real-time collaboration** via WebSockets
- **Scrollable & Zoomable Canvas**
- **User authentication** with JWT
- **Admin panel** for user and project management
- **Project versioning and session persistence** (projects stored in PostgreSQL, sessions currently use in-memory storage with partial DB integration)
- **Secure database connection** using PostgreSQL

## Installation

### Prerequisites

- Docker & Docker Compose

### Steps

1. Clone the repository:
   ```sh
   git clone https://github.com/your-repo/board-game-prototyping-app.git
   cd board-game-prototyping-app
   ```
2. Create an `.env` file:
   ```sh
   cp .env.example .env
   ```
3. Start the application with Docker:
   ```sh
   docker-compose up --build
   ```

## Folder Structure

```
board-game-prototyping-app/
├── server/
│   ├── index.js                # Main server file
│   ├── database.js             # PostgreSQL database connection
│   ├── sessionManager.js       # Manages session persistence (currently partial, in-memory)
│   ├── routes/
│   │   ├── auth.js             # Authentication routes
│   │   ├── projects.js         # Project CRUD & versioning
│   │   ├── admin.js            # Admin controls
│   │   └── collaboration.js    # (Optional) HTTP routes for collaboration
│   ├── ws/
│   │   └── collaboration.js    # WebSocket event handling
│   └── config.js               # Environment variables
│
├── client/
│   ├── index.html              # Base HTML structure
│   ├── js/
│   │   ├── app.js              # Main frontend logic (login, user session handling, etc.)
│   │   ├── canvas.js           # Handles game elements and canvas rendering
│   │   ├── session.js          # WebSockets & session state
│   ├── css/
│   │   ├── style.css           # Styling for the UI
│
├── db-init-scripts/            # Database initialization folder
│   ├── init.sql                # SQL script to create tables
│
├── .env                        # Environment variables
├── docker-compose.yml          # Docker Compose configuration
├── Dockerfile                  # Server Dockerfile
├── package.json                # Node dependencies
├── package-lock.json           # Node lockfile
└── README.md                   # Project documentation
```

## License

This project is licensed under the MIT License.


===== ./package.json =====

{
  "name": "board-game-prototyping-app",
  "version": "0.1.17",
  "type": "module",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "test": "jest"
  },
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.0",
    "pg": "^8.10.0",
    "ws": "^8.11.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.9",
    "@babel/preset-env": "^7.26.9",
    "@testing-library/dom": "^9.3.4",
    "@testing-library/user-event": "^14.6.1",
    "jest": "^29.0.0",
    "jest-canvas-mock": "^2.5.2",
    "jest-environment-jsdom": "^29.7.0",
    "nodemon": "^3.0.1",
    "prettier": "3.5.3",
    "supertest": "^6.0.0"
  },
  "engines": {
    "node": ">=16"
  },
  "license": "MIT"
}


===== ./.env =====

PORT=3000
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgrespassword
DB_NAME=board_game_prototyping
DB_USER=admin
DB_PASSWORD=test1234
DB_HOST=db
DB_PORT=5432
DB_SSL=false
JWT_SECRET=your_jwt_secret
NODE_ENV=development


===== ./docker-compose.yml =====

# docker-compose.yml

services:
  app:
    build: .
    ports:
      - "3000:3000"
    env_file:
      - .env
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app
    command: npm run dev

  db:
    image: postgres:latest
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgrespassword
      POSTGRES_DB: postgres
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data
      - ./db-init-scripts:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      retries: 5
      timeout: 5s

  test:
    build: .
    env_file:
      - .env.test
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app
    working_dir: /app
    command: ["npm", "test"]

volumes:
  pg_data: {}


===== ./babel.config.cjs =====

// babel.config.cjs
module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        targets: { node: "current" },
      },
    ],
  ],
};


===== ./board_game_prototyping.md =====

# Interactive Board Game Prototyping Environment Specification (Updated)

## Purpose

This project aims to create an interactive board game prototyping environment that allows multiple users to collaborate in real time. Users will be able to connect to a shared session and interact with a full-screen canvas containing various virtual board game elements. The initial focus is to provide a flexible and interactive space for game design and testing, with potential future extensions to support game logic.

---

## Core Features

### Security

- [ ] All text input fields must have security precautions to prevent injection attacks.
- [x] User authentication and data storage must adhere to industry-standard security practices.  
       **Implementation Note**:  
       JWT authentication is used (via `AuthService`) for secure routes, and user passwords are salted & hashed with `bcryptjs`.

### Canvas & User Interaction

- **Scrollable & Zoomable Canvas**:

  - [x] The canvas has a fixed center point and supports zooming.
  - [x] Minimum and maximum zoom levels are configurable in code.
  - [x] Clicking and dragging the canvas moves the viewport (panning).
  - [x] Zooming centers on the mouse cursor unless initiated from UI buttons, which center on the visual midpoint.
  - **Implementation Note**:  
    Implemented in `client/js/canvas.js` with real-time rendering updates and transformations.

- **Live Collaboration**:

  - [x] Multiple users in the same session each have a labeled, color-coded icon.
  - [x] Cursor positions of connected users update in real time.
  - [x] Movement or modification of elements propagates to all users.
  - [x] Selections are unique—each user can select or “lock” an element. Locked elements cannot be moved by others.
  - **Implementation Note**:  
    Handled via WebSockets (`server/ws/`). Each user is assigned a color, and the server broadcasts cursor & element changes.

- **Floating UI Elements**:

  - [x] UI elements do not scale with canvas zoom.
  - [x] A floating zoom control UI (bottom-right corner) includes:
    - [x] Zoom percentage display (clickable for manual input is partially implemented).
    - [x] Zoom in/out buttons (+/-) in ~25% increments.
    - [x] A “frame all” button to fit selected elements into view with padding.
  - **Implementation Note**:  
    Implemented with DOM elements in `index.html` and zoom logic in `canvasCamera.js` / `canvas.js`, styled in `style.css`.

- **Tooltips & Tutorials**:

  - [ ] The system should support contextual tooltips or minimal tutorials for usability.
  - **Implementation Note**:  
    Not yet fully implemented beyond basic placeholders.

- **Additional Implemented Feature**:
  - [x] Shape rotation: users can rotate selected shapes via a rotation handle at the corner of the bounding box.

### User Management

- **User Accounts**:

  - [x] Users can register with an email and password.
  - [x] Passwords must be securely stored (via `bcryptjs`).
  - [ ] User preferences (like hotkeys) are planned for future storage.
  - [ ] Users can customize hotkeys (planned).
  - **Implementation Note**:  
    Login/registration routes exist in `auth.js`; user roles are stored in the `users` table.

- **Admin Features**:

  - [x] An admin panel allows user management (updating roles or deleting users).
  - [ ] The admin panel will provide analytics (session counts, user/project stats).
  - [ ] Exporting and importing projects is planned.
  - **Project Rollback** and versioning:
    - [x] Admins can roll back a project to previous saved versions (via `ProjectService.rollbackVersion()`).
    - [ ] If a rolled-back version is unavailable, users are pushed to a new session or receive a notification.
  - [ ] Deleting a project removes it from the database and should invalidate sessions that depend on it (the DB removal is done, session invalidation is not).
  - [ ] Admins can manually force-end older sessions if necessary.
  - **Implementation Note**:
    - Basic admin user management is in `admin.js`.
    - Rollback logic is in `ProjectService.rollbackVersion()`, but forcibly pushing users to new sessions is not fully automated.
    - Analytics and project import/export remain incomplete.

- **Additional Implemented Feature**:
  - [x] Owners or admins can kick users from a session (handled in `permissionHandlers.js`).

### Project & Session Management

- **Session Activity Tracking**:

  - [x] Each session has an activity queue enabling multi-step undo/redo.
  - [x] Undo/redo controls exist as floating UI elements (bottom-left).
  - [x] Project changes to elements (move, create, delete, resize, rotate) are undoable.
  - [x] The undo queue can store up to 50 steps, tracking user actions in order.
  - [ ] If a user disconnects, their undo/redo history should be restored if possible (currently not implemented).
  - **Implementation Note**:  
    Undo/redo logic is in `undoRedoHandlers.js` (server) and triggered by UI in `index.html`.

- **Session Persistence & Project Versioning**:

  - [ ] Sessions should persist with a unique, human-readable code.
  - [ ] Sessions tie explicitly to a project version (currently partial).
  - [ ] If an older project version is used, a popover should warn users.
  - [ ] Sessions can be reset to the last saved state.
  - [ ] Only changes from the original version are tracked until saved.
  - [ ] Session data must be minimal, storing only essential deltas.
  - [ ] Expired sessions remain until manually ended.
  - **Implementation Note**:
    - Project versioning in `project_versions` with rollback and incremental version numbers.
    - Sessions are ephemeral in memory via `SessionService.js`.
    - A more robust naming or persistence scheme is planned.

- **Project Ownership & Permissions**:

  - [x] Users can create, edit, and delete projects.
  - [ ] A project owner can assign permissions to others (beyond admin role) — not yet implemented.
  - [x] Only the owner or admin can delete a project.
  - [x] Only authorized users (owner/admin) can save changes.
  - **Implementation Note**:
    - Owner is tracked via `projects.owner_id`.
    - `ProjectService.userCanEditProject()` checks ownership/admin.

- **Project Loading & Saving**:

  - [x] The site allows opening existing projects or creating new ones (`projects.js`).
  - [x] A default project is automatically created for new users if none exists.
  - [ ] A project has a “saved” state, with changes tracked in sessions (partial).
  - [x] Version number auto-increments on save, older versions remain.
  - [ ] The admin interface should export/import projects and assets (planned).
  - [ ] Image assets persist with the oldest needed version (planned).
  - **Implementation Note**:
    - Creation/listing/saving is in `ProjectService.js` & `routes/projects.js`.
    - Import/export and advanced asset management remain unimplemented.

### Image & Asset Storage

- [ ] Images should be stored at full resolution but optimized for retrieval.
- [ ] Removing an image from a project should preserve it in older versions only.
- [ ] The system should avoid redundant storage by linking to the oldest needed version.
- **Implementation Note**:
  - Actual image uploads/storage are not yet implemented. DB tables are prepared for references, but further development is required.

---

## Real-Time Synchronization

- **Technology Considerations**:

  - [x] The platform uses WebSockets for real-time updates (see `ws/` folder).
  - [x] Latency is minimized by sending immediate local changes and broadcasting them.
  - [x] Some interactions can proceed client-side before server confirmation.
  - [ ] The session’s “owner” typically acts as a tie-breaker if conflicts arise (current logic uses element locking, not explicit owner tie-breaks).
  - [x] PostgreSQL is used for storing project data, with session states in memory.
  - **Implementation Note**:
    - Real-time message flows are in `messageDispatcher.js` plus `ws/handlers/`.
    - Conflict resolution beyond basic locking is still minimal.

---

## Additional Implemented Feature

- **Chat System**:
  - [x] A real-time chat feature is available; messages are broadcast to all users in the session (`chatHandlers.js`, `client/js/app.js`).


===== ./tests/unit/handlerUtils.test.js =====

// tests/unit/handlerUtils.test.js
import { sessionGuard } from "../../server/ws/handlers/handlerUtils.js";

describe("handlerUtils - sessionGuard", () => {
  test("returns immediately if session is falsy", () => {
    const mockFn = jest.fn();
    const guardedFn = sessionGuard(mockFn);

    guardedFn(
      null,
      { some: "data" },
      {
        /* mockWs */
      },
    );
    expect(mockFn).not.toHaveBeenCalled();

    guardedFn(undefined, { some: "data" }, {});
    expect(mockFn).not.toHaveBeenCalled();
  });

  test("calls the wrapped function if session is truthy", () => {
    const mockFn = jest.fn();
    const guardedFn = sessionGuard(mockFn);

    const fakeSession = { code: "test-session" };
    const fakeData = { type: "example" };
    const fakeWs = { readyState: 1 };

    guardedFn(fakeSession, fakeData, fakeWs);
    expect(mockFn).toHaveBeenCalledWith(fakeSession, fakeData, fakeWs);
  });

  test("returns whatever the wrapped function returns", () => {
    const mockFn = jest.fn().mockReturnValue("someValue");
    const guardedFn = sessionGuard(mockFn);

    const out = guardedFn({ code: "test" }, {}, {});
    expect(out).toBe("someValue");
  });
});


===== ./tests/unit/Permissions.test.js =====

// tests/unit/Permissions.test.js

import {
  isAdmin,
  isOwner,
  isEditor,
  isViewer,
  canManageOthers,
  canKickUser,
  canRenameProject,
  canEditProject,
} from "../../server/utils/Permissions.js";

describe("Permissions utility functions", () => {
  const adminUser = {
    userId: "admin1",
    globalRole: "admin",
    sessionRole: "viewer", // even if sessionRole=viewer, globalRole=admin overrides in many checks
  };
  const ownerUser = {
    userId: "owner1",
    globalRole: "user",
    sessionRole: "owner",
  };
  const editorUser = {
    userId: "editor1",
    globalRole: "user",
    sessionRole: "editor",
  };
  const viewerUser = {
    userId: "viewer1",
    globalRole: "user",
    sessionRole: "viewer",
  };

  describe("isAdmin", () => {
    test("admin user => true", () => {
      expect(isAdmin(adminUser)).toBe(true);
    });
    test("non-admin => false", () => {
      expect(isAdmin(ownerUser)).toBe(false);
      expect(isAdmin(editorUser)).toBe(false);
      expect(isAdmin(viewerUser)).toBe(false);
    });
  });

  describe("isOwner", () => {
    test('sessionRole="owner" => true', () => {
      expect(isOwner(ownerUser)).toBe(true);
    });
    test("others => false", () => {
      expect(isOwner(adminUser)).toBe(false);
      expect(isOwner(editorUser)).toBe(false);
      expect(isOwner(viewerUser)).toBe(false);
    });
  });

  describe("isEditor", () => {
    test('sessionRole="editor" => true', () => {
      expect(isEditor(editorUser)).toBe(true);
    });
    test('sessionRole="owner" => true', () => {
      expect(isEditor(ownerUser)).toBe(true);
    });
    test('admin globalRole with viewer session => isEditor= false (strictly speaking, code says only "owner" or "editor")', () => {
      // If you want admins to auto be "editor", you can adjust. Currently, the code is: isEditor = sessionRole==='editor'||'owner'
      // So an admin with sessionRole='viewer' is not recognized as 'editor'. This might be fine or might be a design choice.
      expect(isEditor(adminUser)).toBe(false);
    });
    test('sessionRole="viewer" => false', () => {
      expect(isEditor(viewerUser)).toBe(false);
    });
  });

  describe("isViewer", () => {
    test('sessionRole="viewer" => true', () => {
      expect(isViewer(viewerUser)).toBe(true);
      expect(isViewer(adminUser)).toBe(true); // Because adminUser.sessionRole='viewer'
    });
    test("others => false", () => {
      expect(isViewer(ownerUser)).toBe(false);
      expect(isViewer(editorUser)).toBe(false);
    });
  });

  describe("canManageOthers", () => {
    test("admin => true", () => {
      expect(canManageOthers(adminUser)).toBe(true);
    });
    test("owner => true", () => {
      expect(canManageOthers(ownerUser)).toBe(true);
    });
    test("editor => false", () => {
      expect(canManageOthers(editorUser)).toBe(false);
    });
    test("viewer => false", () => {
      expect(canManageOthers(viewerUser)).toBe(false);
    });
  });

  describe("canKickUser", () => {
    test("admin can kick viewer or editor or user - as long as target is not admin or owner", () => {
      // admin user => canKickUser(adminUser, viewerUser) => true
      expect(canKickUser(adminUser, viewerUser)).toBe(true);
      expect(canKickUser(adminUser, editorUser)).toBe(true);
      // cannot kick another admin
      const admin2 = { ...adminUser, userId: "admin2" };
      expect(canKickUser(adminUser, admin2)).toBe(false);
      // cannot kick an owner
      expect(canKickUser(adminUser, ownerUser)).toBe(false);
    });
    test("owner can kick viewer, editor, but not admin or other owner", () => {
      // owner => canKickUser(ownerUser, viewerUser)=true
      expect(canKickUser(ownerUser, viewerUser)).toBe(true);
      expect(canKickUser(ownerUser, editorUser)).toBe(true);
      // cannot kick admin
      expect(canKickUser(ownerUser, adminUser)).toBe(false);
      // cannot kick another "owner" if that existed
    });
    test("editor or viewer => false always", () => {
      expect(canKickUser(editorUser, viewerUser)).toBe(false);
      expect(canKickUser(viewerUser, editorUser)).toBe(false);
      expect(canKickUser(editorUser, ownerUser)).toBe(false);
      expect(canKickUser(viewerUser, adminUser)).toBe(false);
    });
  });

  describe("canRenameProject (== canManageOthers)", () => {
    test("admin => true", () => {
      expect(canRenameProject(adminUser)).toBe(true);
    });
    test("owner => true", () => {
      expect(canRenameProject(ownerUser)).toBe(true);
    });
    test("editor => false", () => {
      expect(canRenameProject(editorUser)).toBe(false);
    });
  });

  describe("canEditProject", () => {
    test("admin => true", () => {
      expect(canEditProject(adminUser)).toBe(true);
    });
    test("owner => true", () => {
      expect(canEditProject(ownerUser)).toBe(true);
    });
    test("editor => true", () => {
      expect(canEditProject(editorUser)).toBe(true);
    });
    test("viewer => false", () => {
      expect(canEditProject(viewerUser)).toBe(false);
    });
  });
});


===== ./tests/unit/permissionHandlers.test.js =====

// tests/unit/permissionHandlers.test.js
// Only changes shown; the rest is the same structure.

import {
  handleMakeEditor,
  handleRemoveEditor,
  handleKickUser,
} from "../../server/ws/handlers/permissionHandlers.js";
import {
  broadcastUserList,
  broadcastElementState,
  broadcastToSession,
} from "../../server/ws/collabUtils.js";
import { WebSocket } from "ws";

jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastUserList: jest.fn(),
  broadcastElementState: jest.fn(),
  broadcastToSession: jest.fn(),
}));

describe("permissionHandlers", () => {
  let mockSession, mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockWs = { send: jest.fn(), readyState: WebSocket.OPEN };

    mockSession = {
      code: "test-permissions",
      users: new Map(),
      elements: [],
      canManage: jest.fn(), // we still mock it
      setEditorRole: jest.fn(),
      kickUser: jest.fn(),
    };
  });

  test("handleMakeEditor => only works if canManage returns true and user is found", () => {
    const user1 = { userId: "user1", sessionRole: "owner", globalRole: "user" };
    const user2 = {
      userId: "user2",
      sessionRole: "viewer",
      globalRole: "user",
    };
    mockSession.users.set("user1", user1);
    mockSession.users.set("user2", user2);

    mockSession.canManage.mockReturnValue(true);

    handleMakeEditor(
      mockSession,
      { userId: "user1", targetUserId: "user2" },
      mockWs,
    );
    expect(mockSession.setEditorRole).toHaveBeenCalledWith("user2", true);
    expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
  });

  test("handleMakeEditor => does nothing if session.canManage = false", () => {
    mockSession.canManage.mockReturnValue(false);
    handleMakeEditor(mockSession, { userId: "x", targetUserId: "y" }, mockWs);

    expect(mockSession.setEditorRole).not.toHaveBeenCalled();
    expect(broadcastUserList).not.toHaveBeenCalled();
  });

  test("handleRemoveEditor => unsets editor role if canManage = true", () => {
    const adminUser = {
      userId: "admin",
      globalRole: "admin",
      sessionRole: "viewer",
    };
    const normalUser = {
      userId: "u100",
      sessionRole: "editor",
      globalRole: "user",
    };
    mockSession.users.set("admin", adminUser);
    mockSession.users.set("u100", normalUser);

    mockSession.canManage.mockReturnValue(true);

    handleRemoveEditor(
      mockSession,
      { userId: "admin", targetUserId: "u100" },
      mockWs,
    );
    expect(mockSession.setEditorRole).toHaveBeenCalledWith("u100", false);
    expect(broadcastUserList).toHaveBeenCalled();
  });

  test("handleKickUser => calls session.kickUser if canManage, broadcasts", () => {
    const userA = { userId: "userA", sessionRole: "owner", globalRole: "user" };
    const userB = {
      userId: "userB",
      sessionRole: "viewer",
      globalRole: "user",
    };
    mockSession.users.set("userA", userA);
    mockSession.users.set("userB", userB);

    mockSession.kickUser.mockReturnValue({
      userId: "userB",
      socket: { send: jest.fn(), readyState: WebSocket.OPEN },
    });

    handleKickUser(
      mockSession,
      { userId: "userA", targetUserId: "userB" },
      mockWs,
    );

    expect(mockSession.kickUser).toHaveBeenCalledWith("userA", "userB");
    expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
    expect(broadcastElementState).toHaveBeenCalledWith(mockSession);

    // Check kicked user's socket
    const kickedUser = mockSession.kickUser.mock.results[0].value;
    expect(kickedUser.socket.send).toHaveBeenCalledWith(
      JSON.stringify({ type: "kicked" }),
      expect.any(Function),
    );
  });
});


===== ./tests/unit/asyncHandler.test.js =====

// tests/unit/asyncHandler.test.js
import { asyncHandler } from "../../server/utils/asyncHandler.js";

describe("asyncHandler", () => {
  test("calls next with error if the wrapped function rejects", async () => {
    const mockReq = {};
    const mockRes = {};
    const mockNext = jest.fn();

    const failingFn = async () => {
      throw new Error("Oops!");
    };
    const wrapped = asyncHandler(failingFn);

    await wrapped(mockReq, mockRes, mockNext);
    expect(mockNext).toHaveBeenCalledTimes(1);
    const [err] = mockNext.mock.calls[0];
    expect(err.message).toBe("Oops!");
  });

  test("calls the handler normally if no error", async () => {
    const mockReq = {};
    const mockRes = {};
    const mockNext = jest.fn();

    const successFn = async (req, res, next) => {
      // No error
      return "OK";
    };
    const wrapped = asyncHandler(successFn);

    await wrapped(mockReq, mockRes, mockNext);
    expect(mockNext).not.toHaveBeenCalled();
  });
});


===== ./tests/unit/collabUtils.test.js =====

// tests/unit/collabUtils.test.js
import {
  broadcastToSession,
  broadcastElementState,
  broadcastUserList,
} from "../../server/ws/collabUtils.js";
import { WebSocket } from "ws";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

jest.mock("ws", () => {
  const MockWebSocket = jest.fn().mockImplementation(() => ({
    readyState: 1,
    send: jest.fn((msg, cb) => {
      if (cb) cb(); // mimic behavior
    }),
  }));
  MockWebSocket.OPEN = 1;
  return { WebSocket: MockWebSocket };
});

describe("collabUtils", () => {
  let mockSession;

  beforeEach(() => {
    mockSession = {
      code: "test-session",
      projectName: "TestProject",
      elements: [{ id: 1, x: 10, y: 10, w: 50, h: 50, lockedBy: null }],
      users: new Map(),
    };
    const user1Socket = new WebSocket();
    const user2Socket = new WebSocket();
    // user1 => 'owner', user2 => 'viewer'
    mockSession.users.set("user1", {
      userId: "user1",
      socket: user1Socket,
      name: "UserOne",
      color: "#123",
      sessionRole: "owner",
      globalRole: "user",
      joinOrder: 1,
    });
    mockSession.users.set("user2", {
      userId: "user2",
      socket: user2Socket,
      name: "UserTwo",
      color: "#456",
      sessionRole: "viewer",
      globalRole: "admin",
      joinOrder: 2,
    });
  });

  test("broadcastToSession sends stringified data to all connected user sockets", () => {
    broadcastToSession(mockSession, { type: "TEST_MESSAGE", hello: "world" });

    for (const user of mockSession.users.values()) {
      expect(user.socket.send).toHaveBeenCalledTimes(1);
      const sentMsg = user.socket.send.mock.calls[0][0];
      expect(JSON.parse(sentMsg)).toMatchObject({
        type: "TEST_MESSAGE",
        hello: "world",
      });
    }
  });

  test("broadcastElementState sends ELEMENT_STATE with elements & projectName", () => {
    broadcastElementState(mockSession);

    for (const user of mockSession.users.values()) {
      expect(user.socket.send).toHaveBeenCalledTimes(1);
      const msg = JSON.parse(user.socket.send.mock.calls[0][0]);
      expect(msg.type).toBe(MESSAGE_TYPES.ELEMENT_STATE);
      expect(msg.elements).toEqual(mockSession.elements);
      expect(msg.projectName).toBe(mockSession.projectName);
    }
  });

  test("broadcastUserList sends SESSION_USERS array with sessionRole & globalRole, no ownerUserId", () => {
    broadcastUserList(mockSession);

    for (const user of mockSession.users.values()) {
      expect(user.socket.send).toHaveBeenCalledTimes(1);
      const msg = JSON.parse(user.socket.send.mock.calls[0][0]);
      expect(msg.type).toBe(MESSAGE_TYPES.SESSION_USERS);

      expect(Array.isArray(msg.users)).toBe(true);
      expect(msg.users.length).toBe(2);

      // user1 => sessionRole='owner'
      const u1 = msg.users.find((u) => u.userId === "user1");
      expect(u1.sessionRole).toBe("owner");
      expect(u1.globalRole).toBe("user");

      // user2 => sessionRole='viewer', globalRole='admin'
      const u2 = msg.users.find((u) => u.userId === "user2");
      expect(u2.sessionRole).toBe("viewer");
      expect(u2.globalRole).toBe("admin");

      // We do NOT send an 'ownerUserId' property anymore
      expect(msg).not.toHaveProperty("ownerUserId");
    }
  });

  test("broadcastToSession does nothing if user socket is missing or not open", () => {
    // user2 => no socket
    mockSession.users.get("user2").socket = null;
    // user1 => closed
    mockSession.users.get("user1").socket.readyState = 3; // CLOSED

    broadcastToSession(mockSession, { type: "ANY" });

    for (const user of mockSession.users.values()) {
      if (!user.socket) continue;
      expect(user.socket.send).not.toHaveBeenCalled();
    }
  });
});


===== ./tests/unit/Session.test.js =====

// tests/unit/Session.test.js
import { Session } from "../../server/services/Session.js";

describe("Session class", () => {
  let session;

  beforeEach(() => {
    session = new Session("test-code");
  });

  test("empty session => first user is owner by default", () => {
    expect(session.users.size).toBe(0);
    const user = session.addUser("uFirst", "First");
    expect(user.sessionRole).toBe("owner");
    expect(session.users.size).toBe(1);
  });

  test("first user in an empty session becomes owner, even if re-joining an ID that was never fully set", () => {
    expect(session.users.size).toBe(0);

    const userA = session.addUser("uA", "UserA");
    expect(userA.sessionRole).toBe("owner");
    expect(session.users.size).toBe(1);

    session.removeUser("uA");
    expect(session.users.size).toBe(0);

    const userB = session.addUser("uB", "UserB");
    expect(userB.sessionRole).toBe("owner");
  });

  test("constructor sets initial fields", () => {
    expect(session.code).toBe("test-code");
    expect(session.projectName).toBe("New Project");
    expect(session.users.size).toBe(0);
    expect(session.elements.length).toBe(2);
    expect(session.undoStack.length).toBe(0);
    expect(session.redoStack.length).toBe(0);
  });

  test("addUser => first user becomes owner, subsequent do not", () => {
    const user1 = session.addUser("u1", "Alice");
    expect(user1.sessionRole).toBe("owner");
    const user2 = session.addUser("u2", "Bob");
    expect(user2.sessionRole).toBe("viewer");
    expect(session.users.size).toBe(2);
  });

  test("addUser => can set admin if isAdminFlag = true", () => {
    const adminUser = session.addUser("admin_1", "AdminUser", true);
    expect(adminUser.globalRole).toBe("admin");
  });

  test("addUser => re-joining a user updates name/socket if provided", () => {
    const initial = session.addUser("user1", "FirstName");
    expect(initial.name).toBe("FirstName");
    expect(session.users.size).toBe(1);

    const rejoined = session.addUser("user1", "NewName");
    expect(rejoined.userId).toBe("user1");
    expect(rejoined.name).toBe("NewName");
    expect(session.users.size).toBe(1);
  });

  test("removeUser => frees locks, reassigns owner if needed", () => {
    const owner = session.addUser("owner1", "Owner1");
    const user2 = session.addUser("user2", "Regular");
    session.elements.push({ id: 99, lockedBy: "user2" });

    session.removeUser("user2");
    const lockedEl = session.elements.find((el) => el.id === 99);
    expect(lockedEl.lockedBy).toBe(null);
    expect(session.users.size).toBe(1);

    // remove the owner => now 0 users, no owners
    session.removeUser("owner1");
    expect(session.users.size).toBe(0);
  });

  test("kickUser => must be owner/admin, cannot kick owners/admins, returns kicked user or null", () => {
    const owner = session.addUser("owner1", "OwnerUser");
    owner.isOwner = true; // for test scenario

    const normal = session.addUser("u2", "User2");
    const kicked = session.kickUser("owner1", "u2");
    expect(kicked.userId).toBe("u2");
    expect(session.users.has("u2")).toBe(false);

    const user2Again = session.addUser("u2", "User2Again", true);
    const failKick = session.kickUser("owner1", "u2"); // can't kick admin
    expect(failKick).toBeNull();
    expect(session.users.has("u2")).toBe(true);

    const adminKickOwner = session.kickUser("u2", "owner1");
    expect(adminKickOwner).toBeNull();
  });

  test("upgradeUserId => merges old locks, sets new ID, merges admin if requested", () => {
    session.addUser("anon_1", "Anon");
    session.elements.push({ id: 101, lockedBy: "anon_1" });

    const upgraded = session.upgradeUserId(
      "anon_1",
      "real_99",
      "RealName",
      true,
    );
    expect(upgraded.userId).toBe("real_99");
    expect(upgraded.name).toBe("RealName");
    expect(upgraded.globalRole).toBe("admin");

    const el = session.elements.find((e) => e.id === 101);
    expect(el.lockedBy).toBe("real_99");
  });

  test("upgradeUserId => preserves sessionRole=owner if old user was owner", () => {
    const anonOwner = session.addUser("anon_owner", "Ephemeral Owner");
    expect(anonOwner.sessionRole).toBe("owner");

    const realUser = session.upgradeUserId(
      "anon_owner",
      "user_10",
      "RealUser",
      false,
    );
    expect(realUser.sessionRole).toBe("owner");
  });

  test("upgradeUserId => handles non-existent oldUserId by creating placeholder", () => {
    const out = session.upgradeUserId(
      "fakeId",
      "newId",
      "NewName",
      false,
      null,
    );
    expect(out.userId).toBe("newId");
    expect(out.name).toBe("NewName");
    expect(session.users.has("fakeId")).toBe(false);
    expect(session.users.has("newId")).toBe(true);
  });

  test("downgradeUserId => merges locks, sets new ID as viewer, clears admin/owner/editor", () => {
    const user = session.addUser("u111", "TestUser", true); // => globalRole='admin'
    user.sessionRole = "owner";

    session.elements.push({ id: 200, lockedBy: "u111" });

    const downgraded = session.downgradeUserId("u111", "anon_99");
    expect(downgraded.userId).toBe("anon_99");
    expect(downgraded.globalRole).toBe("user");
    expect(downgraded.sessionRole).toBe("viewer");

    const el = session.elements.find((e) => e.id === 200);
    expect(el.lockedBy).toBe("anon_99");
  });

  test("downgradeUserId => handles non-existent oldUserId by creating placeholder, then downgrading", () => {
    const out = session.downgradeUserId("missing_123", "anon_77");
    expect(out.userId).toBe("anon_77");
    expect(out.globalRole).toBe("user");
    expect(out.sessionRole).toBe("viewer");
    expect(session.users.has("missing_123")).toBe(false);
    expect(session.users.has("anon_77")).toBe(true);
  });

  test("setEditorRole => toggles user.sessionRole between editor/viewer", () => {
    const user = session.addUser("uX", "UserX");
    session.setEditorRole("uX", true);
    expect(session.users.get("uX").sessionRole).toBe("editor");
    session.setEditorRole("uX", false);
    expect(session.users.get("uX").sessionRole).toBe("viewer");
  });

  test("clearUndoRedo => empties undoStack and redoStack", () => {
    session.undoStack.push({ action: "test1" });
    session.redoStack.push({ action: "test2" });
    session.clearUndoRedo();
    expect(session.undoStack.length).toBe(0);
    expect(session.redoStack.length).toBe(0);
  });

  // -------------------- NEW TESTS FOR PENDING MOVES/RESIZES --------------------

  test("upgradeUserId => transfers pendingMoves and pendingResizes from old to new userId", () => {
    // Setup a partial move
    session.pendingMoves.set(10, {
      userId: "anon_123",
      oldX: 50,
      oldY: 60,
    });
    // Setup partial resize
    const resizeMap = new Map();
    resizeMap.set(20, { x: 100, y: 200, w: 40, h: 40 });
    session.pendingResizes.set("anon_123", resizeMap);

    // Now upgrade
    session.upgradeUserId("anon_123", "realUser_1", "RealName", false, null);

    // The old key "anon_123" in pendingResizes should be gone
    expect(session.pendingResizes.has("anon_123")).toBe(false);

    // The new user has the same sub-map
    expect(session.pendingResizes.has("realUser_1")).toBe(true);
    const newMap = session.pendingResizes.get("realUser_1");
    expect(newMap.get(20)).toEqual({ x: 100, y: 200, w: 40, h: 40 });

    // The pendingMoves entry changed userId
    expect(session.pendingMoves.get(10)).toEqual({
      userId: "realUser_1",
      oldX: 50,
      oldY: 60,
    });
  });

  test("downgradeUserId => merges pendingMoves and pendingResizes similarly", () => {
    // Suppose we have partial moves/resizes under "u222"
    session.pendingMoves.set(7, {
      userId: "u222",
      oldX: 0,
      oldY: 0,
    });
    const rMap = new Map();
    rMap.set(99, { x: 10, y: 20, w: 30, h: 40 });
    session.pendingResizes.set("u222", rMap);

    // Downgrade
    session.downgradeUserId("u222", "anon_444");

    // old keys removed
    expect(session.pendingMoves.get(7).userId).toBe("anon_444");
    expect(session.pendingResizes.has("u222")).toBe(false);

    // new keys found
    const newMap = session.pendingResizes.get("anon_444");
    expect(newMap.size).toBe(1);
    expect(newMap.get(99)).toEqual({ x: 10, y: 20, w: 30, h: 40 });
  });
});


===== ./tests/unit/config.test.js =====

// tests/unit/config.test.js
describe("config.js under NODE_ENV=test", () => {
  let originalEnv;

  beforeAll(() => {
    originalEnv = { ...process.env };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  test("Node environment is pinned to test => DB_NAME forced; DB_USER, etc. come from env", () => {
    process.env.NODE_ENV = "test";
    // Suppose .env.test or Docker sets DB_USER=admin, DB_PASSWORD=whatever

    jest.resetModules();
    const config = require("../../server/config.js").default;

    // DB_NAME forced to test
    expect(config.DB_NAME).toBe("board_game_prototyping_test");

    // DB_USER might be 'admin' if your .env.test says so:
    expect(config.DB_USER).toBe("admin");

    // If DB_PASSWORD is set in .env.test as well, we confirm that:
    // expect(config.DB_PASSWORD).toBe('mySecretPassword');

    // If DB_SSL is 'true', then:
    // expect(config.DB_SSL).toBe(true);

    // Or you can do partial checks if you're not sure
  });
});


===== ./tests/unit/UserService.test.js =====

// tests/unit/UserService.test.js
import bcrypt from "bcryptjs";
import { UserService } from "../../server/services/UserService.js";
import pool from "../../server/database.js";
import { HttpError } from "../../server/utils/HttpError.js";

// Mock the database module
jest.mock("../../server/database.js", () => {
  return {
    __esModule: true,
    default: {
      query: jest.fn(),
    },
  };
});

describe("UserService", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("createUser throws HttpError if email already used", async () => {
    pool.query.mockResolvedValueOnce({
      rows: [{ id: 1, email: "existing@example.com" }],
    });

    await expect(
      UserService.createUser("TestUser", "existing@example.com", "pass123"),
    ).rejects.toThrow(HttpError);
    expect(pool.query).toHaveBeenCalledTimes(1);
  });

  test("createUser inserts a new user if email not found", async () => {
    // 1) DB returns empty => no user
    pool.query.mockResolvedValueOnce({ rows: [] });

    // 2) Insert the new user
    pool.query.mockResolvedValueOnce({
      rows: [{ id: 2, name: "TestUser", email: "test@example.com" }],
    });

    const result = await UserService.createUser(
      "TestUser",
      "test@example.com",
      "pass123",
    );
    expect(pool.query).toHaveBeenCalledTimes(2);
    expect(result).toMatchObject({
      id: 2,
      name: "TestUser",
      email: "test@example.com",
    });
  });

  test("comparePasswords returns true for correct match", async () => {
    const plain = "secret";
    const hashed = await bcrypt.hash(plain, 10);
    const isMatch = await UserService.comparePasswords(plain, hashed);
    expect(isMatch).toBe(true);
  });

  test("comparePasswords returns false for incorrect match", async () => {
    const plain = "secret";
    const hashed = await bcrypt.hash("otherpassword", 10);
    const isMatch = await UserService.comparePasswords(plain, hashed);
    expect(isMatch).toBe(false);
  });
});


===== ./tests/unit/sessionHandlers.test.js =====

// tests/unit/sessionHandlers.test.js

import {
  handleJoinSession,
  handleUpgradeUserId,
  handleDowngradeUserId,
} from "../../server/ws/handlers/sessionHandlers.js";
import { SessionService } from "../../server/services/SessionService.js";
import {
  broadcastUserList,
  broadcastElementState,
} from "../../server/ws/collabUtils.js";

jest.mock("../../server/services/SessionService.js");
jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastUserList: jest.fn(),
  broadcastElementState: jest.fn(),
}));

describe("sessionHandlers", () => {
  let mockSession;
  let mockWs;

  beforeEach(() => {
    jest.clearAllMocks();

    mockWs = { send: jest.fn(), sessionCode: undefined, userId: undefined };

    // Our "session" object is the actual one passed to handlers. We'll provide
    // mock methods where needed: addUser, upgradeUserId, etc.
    mockSession = {
      code: "test-session-code",
      addUser: jest.fn(),
      upgradeUserId: jest.fn(),
      downgradeUserId: jest.fn(),
      users: new Map(),
      elements: [
        { id: 1, lockedBy: null },
        { id: 2, lockedBy: null },
      ],
    };
  });

  describe("handleJoinSession", () => {
    test("creates or fetches session, joins user, sets ws fields, broadcasts", () => {
      SessionService.getOrCreateSession.mockReturnValue(mockSession);

      // Mock addUser to illustrate returning some user object
      mockSession.addUser.mockReturnValue({
        userId: "userA",
        name: "Alice",
        isAdmin: true,
      });

      const data = {
        type: "join-session",
        userId: "userA",
        sessionCode: "test-session-code",
        name: "Alice",
        userRole: "admin",
      };

      handleJoinSession(null, data, mockWs);

      expect(SessionService.getOrCreateSession).toHaveBeenCalledWith(
        "test-session-code",
      );
      expect(mockSession.addUser).toHaveBeenCalledWith(
        "userA",
        "Alice",
        true,
        mockWs,
      );

      expect(mockWs.sessionCode).toBe("test-session-code");
      expect(mockWs.userId).toBe("userA");

      expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
      expect(broadcastElementState).toHaveBeenCalledWith(mockSession);
    });

    test("if session is already passed in, does not call getOrCreateSession again", () => {
      // We do NOT want SessionService.getOrCreateSession called
      mockSession.addUser.mockReturnValue({
        userId: "userA",
        name: "TestUser",
      });

      const data = {
        userId: "userA",
        sessionCode: "some-other-code",
        name: "Test",
      };

      handleJoinSession(mockSession, data, mockWs);

      // We already have a session => no fetch
      expect(SessionService.getOrCreateSession).not.toHaveBeenCalled();

      // We do expect addUser => third param is undefined if userRole not 'admin'
      expect(mockSession.addUser).toHaveBeenCalledWith(
        "userA",
        "Test",
        undefined,
        mockWs,
      );

      expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
      expect(broadcastElementState).toHaveBeenCalledWith(mockSession);
    });

    test("if userId is missing, does nothing", () => {
      handleJoinSession(mockSession, { sessionCode: "test" }, mockWs);

      expect(mockSession.addUser).not.toHaveBeenCalled();
      expect(broadcastUserList).not.toHaveBeenCalled();
      expect(broadcastElementState).not.toHaveBeenCalled();
    });
  });

  describe("handleUpgradeUserId", () => {
    test("calls session.upgradeUserId, reassigns ws.userId, then broadcasts", () => {
      mockSession.upgradeUserId.mockReturnValue({ userId: "newUid" });

      const data = {
        oldUserId: "temp_1",
        newUserId: "real_99",
        newName: "Bob",
        newIsAdmin: true,
      };

      handleUpgradeUserId(mockSession, data, mockWs);

      expect(mockSession.upgradeUserId).toHaveBeenCalledWith(
        "temp_1",
        "real_99",
        "Bob",
        true,
        mockWs,
      );
      expect(mockWs.userId).toBe("newUid");

      expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
      expect(broadcastElementState).toHaveBeenCalledWith(mockSession);
    });

    test("does nothing if session is null", () => {
      handleUpgradeUserId(null, { oldUserId: "u1" }, mockWs);

      expect(broadcastUserList).not.toHaveBeenCalled();
      expect(broadcastElementState).not.toHaveBeenCalled();
    });
  });

  describe("handleDowngradeUserId", () => {
    test("calls session.downgradeUserId, reassigns ws.userId, then broadcasts", () => {
      mockSession.downgradeUserId.mockReturnValue({ userId: "anon_123" });

      const data = { oldUserId: "user_7", newUserId: "anon_111" };
      handleDowngradeUserId(mockSession, data, mockWs);

      expect(mockSession.downgradeUserId).toHaveBeenCalledWith(
        "user_7",
        "anon_111",
        mockWs,
      );
      expect(mockWs.userId).toBe("anon_123");

      expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
      expect(broadcastElementState).toHaveBeenCalledWith(mockSession);
    });

    test("does nothing if session is null", () => {
      handleDowngradeUserId(null, { oldUserId: "u1" }, mockWs);

      expect(broadcastUserList).not.toHaveBeenCalled();
      expect(broadcastElementState).not.toHaveBeenCalled();
    });
  });
});


===== ./tests/unit/SessionService.test.js =====

// tests/unit/SessionService.test.js
import { SessionService } from "../../server/services/SessionService.js";
import { Session } from "../../server/services/Session.js";

describe("SessionService", () => {
  beforeEach(() => {
    // Clear the sessionMap by removing known sessions
    SessionService.removeSession("test-code-1");
    SessionService.removeSession("test-code-2");
  });

  test("getOrCreateSession creates a new Session instance", () => {
    const s = SessionService.getSession("test-code-1");
    expect(s).toBeNull();

    const created = SessionService.getOrCreateSession("test-code-1");
    expect(created).toBeInstanceOf(Session);

    const again = SessionService.getSession("test-code-1");
    expect(again).toBe(created);
  });

  test("removeSession deletes from the map", () => {
    const s = SessionService.getOrCreateSession("test-code-2");
    expect(SessionService.getSession("test-code-2")).toBe(s);

    SessionService.removeSession("test-code-2");
    expect(SessionService.getSession("test-code-2")).toBeNull();
  });
});


===== ./tests/unit/elementHandlers.test.js =====

// tests/unit/elementHandlers.test.js

import {
  handleElementGrab,
  handleElementMove,
  handleElementRelease,
  handleElementDeselect,
  handleElementCreate,
  handleElementDelete,
  handleElementResize,
  handleElementResizeEnd,
} from "../../server/ws/handlers/elementHandlers.js";
import { broadcastElementState } from "../../server/ws/collabUtils.js";
import { pushUndoAction } from "../../server/ws/handlers/undoRedoHandlers.js";

jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastElementState: jest.fn(),
}));
jest.mock("../../server/ws/handlers/undoRedoHandlers.js", () => ({
  pushUndoAction: jest.fn(),
}));

describe("elementHandlers", () => {
  let mockSession;
  let mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockWs = { send: jest.fn() };

    mockSession = {
      code: "test-element-session",
      elements: [
        { id: 1, x: 0, y: 0, w: 50, h: 50, angle: 0, lockedBy: null },
        {
          id: 2,
          x: 10,
          y: 10,
          w: 100,
          h: 40,
          angle: 0,
          lockedBy: "someoneElse",
        },
      ],
    };
  });

  test("handleElementRotate => locks element if needed, updates angle, broadcasts", () => {
    handleElementRotate(
      mockSession,
      { userId: "userA", elementId: 1, angle: 45 },
      mockWs,
    );
    expect(mockSession.elements[0].lockedBy).toBe("userA");
    expect(mockSession.elements[0].angle).toBe(45);
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementRotate => does nothing if locked by another user", () => {
    mockSession.elements[0].lockedBy = "someoneElse";
    handleElementRotate(
      mockSession,
      { userId: "userA", elementId: 1, angle: 90 },
      mockWs,
    );
    expect(mockSession.elements[0].angle).toBe(0); // unchanged
    expect(broadcastElementState).not.toHaveBeenCalled();
  });

  test("handleElementRotateEnd => finalizes undo action if angle changed", () => {
    // Suppose userA locked & changed angle from 0 to 30
    mockSession.elements[0].lockedBy = "userA";
    mockSession.elements[0].angle = 30;

    // pendingRotations => oldAngle=0
    mockSession.pendingRotations = new Map([["userA", new Map([[1, 0]])]]);

    handleElementRotateEnd(
      mockSession,
      { userId: "userA", elementIds: [1] },
      mockWs,
    );
    expect(pushUndoAction).toHaveBeenCalledWith(
      expect.any(Object),
      expect.objectContaining({
        type: "rotate",
        diffs: [
          {
            elementId: 1,
            fromAngle: 0,
            toAngle: 30,
          },
        ],
      }),
    );
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementGrab => locks element if not locked or locked by self", () => {
    handleElementGrab(mockSession, { userId: "userA", elementId: 1 }, mockWs);
    expect(mockSession.elements[0].lockedBy).toBe("userA");
    expect(broadcastElementState).toHaveBeenCalled();

    // Trying to grab an element locked by another user => no effect
    broadcastElementState.mockClear();
    handleElementGrab(mockSession, { userId: "userA", elementId: 2 }, mockWs);
    expect(mockSession.elements[1].lockedBy).toBe("someoneElse");
    expect(broadcastElementState).not.toHaveBeenCalled();
  });

  test("handleElementMove => moves the element if locked by user", () => {
    // elementId=1 is locked by userA
    mockSession.elements[0].lockedBy = "userA";
    handleElementMove(
      mockSession,
      {
        userId: "userA",
        elementId: 1,
        x: 100,
        y: 200,
      },
      mockWs,
    );
    expect(mockSession.elements[0].x).toBe(100);
    expect(mockSession.elements[0].y).toBe(200);
    expect(broadcastElementState).toHaveBeenCalledTimes(1);

    // Another user tries to move it => no effect
    broadcastElementState.mockClear();
    handleElementMove(
      mockSession,
      {
        userId: "userB",
        elementId: 1,
        x: 999,
        y: 999,
      },
      mockWs,
    );
    expect(mockSession.elements[0].x).toBe(100);
    expect(mockSession.elements[0].y).toBe(200);
    expect(broadcastElementState).not.toHaveBeenCalled();
  });

  test("handleElementRelease => does nothing except broadcast if locked by same user", () => {
    mockSession.elements[0].lockedBy = "userA";
    handleElementRelease(
      mockSession,
      { userId: "userA", elementId: 1 },
      mockWs,
    );
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementDeselect => unlocks elements if locked by user", () => {
    mockSession.elements[0].lockedBy = "userA";
    mockSession.elements[1].lockedBy = "someoneElse";

    handleElementDeselect(
      mockSession,
      {
        userId: "userA",
        elementIds: [1, 2],
      },
      mockWs,
    );

    // #1 is unlocked, #2 remains locked by someoneElse
    expect(mockSession.elements[0].lockedBy).toBe(null);
    expect(mockSession.elements[1].lockedBy).toBe("someoneElse");
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementCreate => pushes a new element locked by user, calls pushUndoAction", () => {
    handleElementCreate(
      mockSession,
      {
        userId: "userA",
        shape: "rectangle",
        x: 50,
        y: 60,
        w: 30,
        h: 40,
      },
      mockWs,
    );

    // The new element is appended
    expect(mockSession.elements.length).toBe(3);
    const newEl = mockSession.elements[2];
    expect(newEl).toMatchObject({
      shape: "rectangle",
      x: 50,
      y: 60,
      w: 30,
      h: 40,
      lockedBy: "userA",
    });

    // pushUndoAction was called
    expect(pushUndoAction).toHaveBeenCalled();
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementDelete => removes elements locked by user, creates undo action", () => {
    // Lock element #1 to userA
    mockSession.elements[0].lockedBy = "userA";

    handleElementDelete(
      mockSession,
      {
        userId: "userA",
        elementIds: [1, 2],
      },
      mockWs,
    );

    // #1 is deleted, #2 was locked by someoneElse => not deleted
    expect(mockSession.elements.some((e) => e.id === 1)).toBe(false);
    expect(mockSession.elements.some((e) => e.id === 2)).toBe(true);

    // pushUndoAction called with type=delete
    expect(pushUndoAction).toHaveBeenCalledWith(
      expect.any(Object),
      expect.objectContaining({ type: "delete" }),
    );
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementResize => if not locked, auto-lock, store old pos in global groupResizes, updates element", () => {
    // Over the wire, we do not see global data, but let's just check that the element is updated
    // and broadcast is called. We won't deeply test the global groupResizes logic, but we’ll ensure no errors.
    handleElementResize(
      mockSession,
      {
        userId: "userA",
        elementId: 1,
        x: 10,
        y: 20,
        w: 80,
        h: 40,
      },
      mockWs,
    );

    expect(mockSession.elements[0]).toMatchObject({
      x: 10,
      y: 20,
      w: 80,
      h: 40,
      lockedBy: "userA",
    });
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleElementResizeEnd => triggers pushUndoAction if changes occurred", () => {
    // Lock #1 to userA, set up a known initial pos
    mockSession.elements[0] = {
      id: 1,
      x: 0,
      y: 0,
      w: 50,
      h: 50,
      lockedBy: "userA",
    };

    // Emulate that the global group resize storage has original positions (pretend partial),
    // but for a quick test, we rely on the function's internal logic to do diffs if any.
    // We'll just call it and ensure broadcast/pushUndoAction is invoked.
    handleElementResizeEnd(
      mockSession,
      {
        userId: "userA",
        elementIds: [1],
      },
      mockWs,
    );

    // We expect pushUndoAction to have been called if there was a change. But by default,
    // there's no actual "stored old pos" in your global, so let's see we get no diffs.
    // => Probably no undo action is created (the code inside tries to read global objects).
    // So let's just confirm it doesn't crash and calls broadcast:
    expect(broadcastElementState).toHaveBeenCalled();
  });
});


===== ./tests/unit/projectHandlers.test.js =====

// tests/unit/projectHandlers.test.js
import { handleProjectNameChange } from "../../server/ws/handlers/projectHandlers.js";
import {
  broadcastToSession,
  broadcastElementState,
} from "../../server/ws/collabUtils.js";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastToSession: jest.fn(),
  broadcastElementState: jest.fn(),
}));

describe("projectHandlers", () => {
  let mockSession, mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockWs = { send: jest.fn() };
    mockSession = {
      code: "proj-test",
      projectName: "Old Name",
      users: new Map(),
      elements: [],
    };
  });

  test("handleProjectNameChange => sets session.projectName, broadcasts if user isOwner", () => {
    // previously had: user = { userId: 'owner1', isOwner: true }
    const user = { userId: "owner1", sessionRole: "owner", globalRole: "user" };
    mockSession.users.set("owner1", user);

    const data = { userId: "owner1", newName: "NewProjectName" };
    handleProjectNameChange(mockSession, data, mockWs);

    expect(mockSession.projectName).toBe("NewProjectName");
    expect(broadcastToSession).toHaveBeenCalledWith(mockSession, {
      type: MESSAGE_TYPES.PROJECT_NAME_CHANGE,
      newName: "NewProjectName",
    });
    expect(broadcastElementState).toHaveBeenCalledWith(mockSession);
  });

  test("handleProjectNameChange => sets session.projectName, broadcasts if user isAdmin", () => {
    // previously had: user = { userId: 'admin1', isAdmin: true }
    const adminUser = {
      userId: "admin1",
      sessionRole: "viewer",
      globalRole: "admin",
    };
    mockSession.users.set("admin1", adminUser);

    const data = { userId: "admin1", newName: "AdminRenamedIt" };
    handleProjectNameChange(mockSession, data, mockWs);

    expect(mockSession.projectName).toBe("AdminRenamedIt");
    expect(broadcastToSession).toHaveBeenCalled();
    expect(broadcastElementState).toHaveBeenCalled();
  });

  test("handleProjectNameChange => does nothing if user is normal user", () => {
    const user2 = {
      userId: "user2",
      sessionRole: "viewer",
      globalRole: "user",
    };
    mockSession.users.set("user2", user2);

    const data = { userId: "user2", newName: "Nope" };
    handleProjectNameChange(mockSession, data, mockWs);

    expect(mockSession.projectName).toBe("Old Name");
    expect(broadcastToSession).not.toHaveBeenCalled();
    expect(broadcastElementState).not.toHaveBeenCalled();
  });

  test("handleProjectNameChange => does nothing if no newName or userId", () => {
    handleProjectNameChange(mockSession, {}, mockWs);
    expect(mockSession.projectName).toBe("Old Name");
    expect(broadcastToSession).not.toHaveBeenCalled();
  });

  test("handleProjectNameChange => does nothing if session is null", () => {
    handleProjectNameChange(null, { userId: "owner1", newName: "X" }, mockWs);
    expect(broadcastToSession).not.toHaveBeenCalled();
  });
});


===== ./tests/unit/cursorHandlers.test.js =====

// tests/unit/cursorHandlers.test.js
import { handleCursorUpdate } from "../../server/ws/handlers/cursorHandlers.js";
import { broadcastToSession } from "../../server/ws/collabUtils.js";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastToSession: jest.fn(),
}));

describe("cursorHandlers", () => {
  let mockSession;
  let mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockWs = { send: jest.fn() };
    mockSession = {
      code: "cursor-test",
      users: new Map(),
    };
    mockSession.users.set("userA", { userId: "userA", x: 0, y: 0 });
    mockSession.users.set("userB", { userId: "userB", x: 100, y: 100 });
  });

  test("handleCursorUpdate => updates user x,y and broadcasts", () => {
    handleCursorUpdate(mockSession, { userId: "userA", x: 50, y: 60 }, mockWs);

    const updated = mockSession.users.get("userA");
    expect(updated.x).toBe(50);
    expect(updated.y).toBe(60);

    expect(broadcastToSession).toHaveBeenCalledWith(mockSession, {
      type: MESSAGE_TYPES.CURSOR_UPDATE,
      userId: "userA",
      x: 50,
      y: 60,
    });
  });

  test("handleCursorUpdate => does nothing if user not in session", () => {
    broadcastToSession.mockClear();
    handleCursorUpdate(
      mockSession,
      { userId: "unknown", x: 99, y: 99 },
      mockWs,
    );
    expect(broadcastToSession).not.toHaveBeenCalled();
  });

  test("handleCursorUpdate => does nothing if session is null or undefined", () => {
    handleCursorUpdate(null, { userId: "userA", x: 10, y: 10 }, mockWs);
    expect(broadcastToSession).not.toHaveBeenCalled();
  });
});


===== ./tests/unit/HttpError.test.js =====

// tests/unit/HttpError.test.js
import { HttpError } from "../../server/utils/HttpError.js";

describe("HttpError", () => {
  test("creates an error with a message and statusCode", () => {
    const err = new HttpError("Not Found", 404);
    expect(err.message).toBe("Not Found");
    expect(err.statusCode).toBe(404);
    expect(err.stack).toBeDefined();
    // The name property should be 'Error' or 'HttpError' depending on environment
    expect(err.name).toBe("HttpError");
  });

  test("defaults to statusCode=500 if not provided", () => {
    const err = new HttpError("Server failure");
    expect(err.statusCode).toBe(500);
  });

  test("stack trace is captured (V8 only)", () => {
    // Just confirm it has a 'stack' property
    expect(new HttpError("Test").stack).toContain("HttpError");
  });
});


===== ./tests/unit/authMiddleware.test.js =====

// tests/unit/authMiddleware.test.js
import {
  authenticateToken,
  authorizeAdmin,
} from "../../server/middleware/authMiddleware.js";
import { AuthService } from "../../server/services/AuthService.js";

jest.mock("../../server/services/AuthService.js");

describe("authMiddleware", () => {
  let mockReq, mockRes, mockNext;
  beforeEach(() => {
    mockReq = {
      headers: {},
      user: null,
    };
    mockRes = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
    };
    mockNext = jest.fn();
    jest.clearAllMocks();
  });

  describe("authenticateToken", () => {
    test("returns 401 if no token provided", () => {
      // no Authorization header
      authenticateToken(mockReq, mockRes, mockNext);
      expect(mockRes.status).toHaveBeenCalledWith(401);
      expect(mockRes.json).toHaveBeenCalledWith({
        message: "Unauthorized: No token provided",
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    test("returns 403 if token is invalid", () => {
      mockReq.headers["authorization"] = "Bearer some_token";
      AuthService.verifyToken.mockImplementation(() => {
        throw new Error("Invalid token");
      });

      authenticateToken(mockReq, mockRes, mockNext);

      expect(mockRes.status).toHaveBeenCalledWith(403);
      expect(mockRes.json).toHaveBeenCalledWith({
        message: "Forbidden: Invalid token",
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    test("sets req.user and calls next if token is valid", () => {
      mockReq.headers["authorization"] = "Bearer valid_jwt";
      AuthService.verifyToken.mockReturnValue({
        id: 123,
        email: "test@example.com",
      });

      authenticateToken(mockReq, mockRes, mockNext);

      expect(AuthService.verifyToken).toHaveBeenCalledWith("valid_jwt");
      expect(mockReq.user).toEqual({ id: 123, email: "test@example.com" });
      expect(mockNext).toHaveBeenCalled();
    });
  });

  describe("authorizeAdmin", () => {
    test("calls next if req.user.isAdmin is true", () => {
      // Suppose authenticateToken was successful => sets req.user
      mockReq.user = { isAdmin: true };
      authorizeAdmin(mockReq, mockRes, mockNext);
      expect(mockNext).toHaveBeenCalled();
    });

    test("returns 403 if user is not admin", () => {
      mockReq.user = { isAdmin: false };
      authorizeAdmin(mockReq, mockRes, mockNext);
      expect(mockRes.status).toHaveBeenCalledWith(403);
      expect(mockRes.json).toHaveBeenCalledWith({
        message: "Access denied. Admins only.",
      });
      expect(mockNext).not.toHaveBeenCalled();
    });
  });
});


===== ./tests/unit/chatHandlers.test.js =====

// tests/unit/chatHandlers.test.js

import { handleChatMessage } from "../../server/ws/handlers/chatHandlers.js";
import { broadcastToSession } from "../../server/ws/collabUtils.js";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastToSession: jest.fn(),
}));

describe("chatHandlers", () => {
  let mockSession, mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockWs = { send: jest.fn() };

    mockSession = {
      code: "test-chat",
      users: new Map(),
      chatMessages: [],
    };
  });

  test("handleChatMessage => appends message to session.chatMessages & broadcasts", () => {
    const data = {
      userId: "userA",
      text: "Hello World",
    };
    handleChatMessage(mockSession, data, mockWs);

    expect(mockSession.chatMessages).toHaveLength(1);
    const msgObj = mockSession.chatMessages[0];
    expect(msgObj.userId).toBe("userA");
    expect(msgObj.text).toBe("Hello World");
    expect(typeof msgObj.timestamp).toBe("number");

    expect(broadcastToSession).toHaveBeenCalledWith(mockSession, {
      type: MESSAGE_TYPES.CHAT_MESSAGE,
      message: msgObj,
    });
  });

  test("handleChatMessage => does nothing if text or userId missing", () => {
    handleChatMessage(mockSession, { text: "" }, mockWs);
    expect(mockSession.chatMessages).toHaveLength(0);
    expect(broadcastToSession).not.toHaveBeenCalled();

    handleChatMessage(mockSession, { userId: "u1" }, mockWs);
    expect(mockSession.chatMessages).toHaveLength(0);
    expect(broadcastToSession).not.toHaveBeenCalled();
  });
});


===== ./tests/unit/undoRedoHandlers.test.js =====

// tests/unit/undoRedoHandlers.test.js
import {
  handleUndo,
  handleRedo,
  pushUndoAction,
} from "../../server/ws/handlers/undoRedoHandlers.js";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

describe("undoRedoHandlers - main tests", () => {
  let session;
  let mockSend;

  beforeEach(() => {
    mockSend = jest.fn();
    session = {
      users: new Map([
        [
          "userA",
          { userId: "userA", socket: { send: mockSend, readyState: 1 } },
        ],
      ]),
      elements: [{ id: 10, x: 0, y: 0, w: 50, h: 50 }],
      undoStack: [],
      redoStack: [],
      pendingMoves: new Map(),
      pendingResizes: new Map(),
    };
  });

  test("pushUndoAction clears redoStack and appends to undoStack", () => {
    session.redoStack = [{ some: "action" }];
    expect(session.redoStack.length).toBe(1);
    pushUndoAction(session, { type: "testAction" });
    expect(session.undoStack.length).toBe(1);
    expect(session.undoStack[0]).toMatchObject({ type: "testAction" });
    expect(session.redoStack.length).toBe(0);
  });

  test("handleUndo does nothing if undoStack is empty", () => {
    handleUndo(session, { userId: "userA" }, {});
    expect(session.undoStack.length).toBe(0);
    expect(mockSend).not.toHaveBeenCalled();
  });

  test("handleUndo reverts the last action if canApplyAction is satisfied", () => {
    // Add an element
    session.elements.push({
      id: 11,
      x: 50,
      y: 50,
      w: 20,
      h: 20,
      lockedBy: null,
    });
    session.undoStack = [
      {
        type: "move",
        diffs: [
          {
            elementId: 11,
            from: { x: 50, y: 50 },
            to: { x: 70, y: 70 },
          },
        ],
      },
    ];
    // The element is currently at x=70,y=70 => pretend it's moved
    session.elements[1].x = 70;
    session.elements[1].y = 70;

    handleUndo(session, { userId: "userA" }, {});

    // We expect that the element is moved back to the 'from' position
    expect(session.elements[1].x).toBe(50);
    expect(session.elements[1].y).toBe(50);

    // Undo stack => now empty
    expect(session.undoStack.length).toBe(0);

    // Redo stack => has the undone action
    expect(session.redoStack.length).toBe(1);

    // We also expect the "ELEMENT_STATE" broadcast
    expect(mockSend).toHaveBeenCalled();
    const lastCall = mockSend.mock.calls[mockSend.mock.calls.length - 1];
    const msgParsed = JSON.parse(lastCall[0]);
    expect(msgParsed.type).toBe(MESSAGE_TYPES.ELEMENT_STATE);
  });

  test("handleUndo sends UNDO_REDO_FAILED if locked by another user", () => {
    // Make the shape locked by someone else
    session.elements[0].lockedBy = "someone_else";
    session.undoStack = [
      {
        type: "move",
        diffs: [{ elementId: 10, from: { x: 0, y: 0 }, to: { x: 10, y: 10 } }],
      },
    ];

    handleUndo(session, { userId: "userA" }, { send: mockSend });

    // We expect a message to userA with type=UNDO_REDO_FAILED
    expect(mockSend).toHaveBeenCalled();
    const [sentJSON] = mockSend.mock.calls[0];
    const data = JSON.parse(sentJSON);
    expect(data.type).toBe(MESSAGE_TYPES.UNDO_REDO_FAILED);
    expect(data.reason).toMatch(/Element locked by another user/);
  });

  test("handleRedo does nothing if redoStack is empty", () => {
    handleRedo(session, { userId: "userA" }, {});
    expect(session.redoStack.length).toBe(0);
    expect(mockSend).not.toHaveBeenCalled();
  });

  test("handleRedo re-applies the last undone action", () => {
    // Suppose we have an undone move action in the redo stack
    session.redoStack.push({
      type: "move",
      diffs: [
        {
          elementId: 10,
          from: { x: 0, y: 0 },
          to: { x: 100, y: 100 },
        },
      ],
    });
    // The element is currently at x=0,y=0

    handleRedo(session, { userId: "userA" }, {});

    // We expect the element is now at x=100,y=100
    expect(session.elements[0].x).toBe(100);
    expect(session.elements[0].y).toBe(100);

    // Undo stack now has the re-applied action
    expect(session.undoStack.length).toBe(1);
    expect(session.redoStack.length).toBe(0);

    // And we broadcast the new element state
    expect(mockSend).toHaveBeenCalled();
    const lastCall = mockSend.mock.calls[mockSend.mock.calls.length - 1];
    const msgParsed = JSON.parse(lastCall[0]);
    expect(msgParsed.type).toBe(MESSAGE_TYPES.ELEMENT_STATE);
  });

  test("handleRedo also fails if an element is locked by another user", () => {
    session.elements[0].lockedBy = "someone_else";
    session.redoStack.push({
      type: "move",
      diffs: [{ elementId: 10, from: { x: 0, y: 0 }, to: { x: 50, y: 60 } }],
    });

    handleRedo(session, { userId: "userA" }, { send: mockSend });

    expect(mockSend).toHaveBeenCalled();
    const data = JSON.parse(mockSend.mock.calls[0][0]);
    expect(data.type).toBe(MESSAGE_TYPES.UNDO_REDO_FAILED);
  });
});

describe("undoRedoHandlers - Extra Coverage (Merged from undoRedoExtra.test.js)", () => {
  function makeSession(elements = []) {
    return {
      users: new Map(),
      elements,
      undoStack: [],
      redoStack: [],
      pendingMoves: new Map(),
      pendingResizes: new Map(),
    };
  }

  let session;
  let mockWsSend;

  beforeEach(() => {
    mockWsSend = jest.fn();
    session = makeSession();
    session.users.set("testUser", {
      userId: "testUser",
      socket: { send: mockWsSend, readyState: 1 },
    });
  });

  test("pushUndoAction with no diffs, then handleUndo => no changes, but coverage for default cases", () => {
    const action = { type: "unknown", diffs: null };
    pushUndoAction(session, action);

    handleUndo(session, { userId: "testUser" }, { send: mockWsSend });
    // The revert sees unknown type => does nothing, but we do broadcast
    const sentJSON = mockWsSend.mock.calls.map((call) => JSON.parse(call[0]));
    const hasElemState = sentJSON.some(
      (msg) => msg.type === MESSAGE_TYPES.ELEMENT_STATE,
    );
    expect(hasElemState).toBe(true);
  });

  test("handleRedo with unknown action type does nothing but still broadcasts", () => {
    session.redoStack.push({ type: "some-strange-action", diffs: [] });

    handleRedo(session, { userId: "testUser" }, { send: mockWsSend });

    const sentJSON = mockWsSend.mock.calls.map((call) => JSON.parse(call[0]));
    const hasElemState = sentJSON.some(
      (msg) => msg.type === MESSAGE_TYPES.ELEMENT_STATE,
    );
    expect(hasElemState).toBe(true);
  });

  test("handleUndo => shape locked by unknown user => returns UNDO_REDO_FAILED", () => {
    session.elements.push({ id: 1, x: 0, y: 0, lockedBy: "otherUser" });
    session.undoStack.push({
      type: "move",
      diffs: [
        {
          elementId: 1,
          from: { x: 0, y: 0 },
          to: { x: 50, y: 60 },
        },
      ],
    });

    handleUndo(session, { userId: "testUser" }, { send: mockWsSend });

    const [sentStr] = mockWsSend.mock.calls[0];
    const msg = JSON.parse(sentStr);
    expect(msg.type).toBe(MESSAGE_TYPES.UNDO_REDO_FAILED);
    expect(msg.reason).toMatch(/Element locked by another user/);
  });
});


===== ./tests/unit/ProjectService.test.js =====

// tests/unit/ProjectService.test.js

import { ProjectService } from "../../server/services/ProjectService.js";
import pool from "../../server/database.js";
import { HttpError } from "../../server/utils/HttpError.js";

jest.mock("../../server/database.js", () => {
  return {
    __esModule: true,
    default: {
      query: jest.fn(),
    },
  };
});

describe("ProjectService - Main Functionality", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("createVersion increments version number correctly", async () => {
    pool.query.mockResolvedValueOnce({ rows: [{ max_ver: 2 }] });
    pool.query.mockResolvedValueOnce({
      rows: [
        {
          id: 10,
          version_number: 3,
          created_at: "2023-01-01",
          project_data: {},
        },
      ],
    });

    const result = await ProjectService.createVersion(123, { some: "data" });
    expect(pool.query).toHaveBeenCalledTimes(2);
    expect(result).toMatchObject({
      id: 10,
      version_number: 3,
      created_at: "2023-01-01",
    });
  });

  test("rollbackVersion throws 404 if old version not found", async () => {
    pool.query.mockResolvedValueOnce({ rows: [] });
    await expect(ProjectService.rollbackVersion(123, 999)).rejects.toThrow(
      HttpError,
    );
    expect(pool.query).toHaveBeenCalledTimes(1);
  });

  test("rollbackVersion creates a new version from old data", async () => {
    pool.query.mockResolvedValueOnce({
      rows: [{ id: 1, version_number: 2, project_data: { key: "old" } }],
    });
    pool.query.mockResolvedValueOnce({ rows: [{ max_ver: 2 }] });
    pool.query.mockResolvedValueOnce({
      rows: [{ id: 2, version_number: 3, created_at: "2023-02-01" }],
    });

    const result = await ProjectService.rollbackVersion(123, 1);
    expect(pool.query).toHaveBeenCalledTimes(3);
    expect(result).toMatchObject({
      message: "Project rolled back successfully",
      newVersion: { id: 2, version_number: 3 },
    });
  });

  test("userCanEditProject returns true if user is admin", async () => {
    const user = { id: 999, role: "admin" };
    // Should short-circuit to true, no DB query
    const canEdit = await ProjectService.userCanEditProject(123, user);
    expect(canEdit).toBe(true);
    expect(pool.query).not.toHaveBeenCalled();
  });

  test("userCanEditProject returns false if project not found", async () => {
    pool.query.mockResolvedValueOnce({ rows: [] }); // getProjectOwnerId => no row
    const user = { id: 50, role: "user" };
    const canEdit = await ProjectService.userCanEditProject(999, user);
    expect(canEdit).toBe(false);
    expect(pool.query).toHaveBeenCalledTimes(1);
  });

  test("userCanEditProject returns true if user is owner", async () => {
    pool.query.mockResolvedValueOnce({ rows: [{ owner_id: 50 }] });
    const user = { id: 50, role: "user" };
    const canEdit = await ProjectService.userCanEditProject(123, user);
    expect(canEdit).toBe(true);
  });

  test("userCanEditProject returns false if user is neither admin nor owner", async () => {
    pool.query.mockResolvedValueOnce({ rows: [{ owner_id: 55 }] });
    const user = { id: 50, role: "user" };
    const canEdit = await ProjectService.userCanEditProject(123, user);
    expect(canEdit).toBe(false);
  });
});

describe("ProjectService - Error Handling (Merged from ProjectServiceErrorHandling)", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("createProject throws an error if INSERT fails", async () => {
    pool.query.mockRejectedValueOnce(new Error("DB insertion error"));

    await expect(
      ProjectService.createProject(999, "TestName", "Desc"),
    ).rejects.toThrow("DB insertion error");

    expect(pool.query).toHaveBeenCalledTimes(1);
  });

  test("listVersions rethrows if DB fails", async () => {
    pool.query.mockRejectedValueOnce(new Error("DB read error"));

    await expect(ProjectService.listVersions(123)).rejects.toThrow(
      "DB read error",
    );
  });

  test("rollbackVersion => if final insertion fails, rethrows error", async () => {
    // 1) Mock that the old version is found
    pool.query.mockResolvedValueOnce({
      rows: [
        { id: 999, version_number: 3, project_data: { key: "someValue" } },
      ],
    });
    // 2) Mock the next query for getMaxVersion => 3
    pool.query.mockResolvedValueOnce({ rows: [{ max_ver: 3 }] });
    // 3) Mock the final insertion to fail
    pool.query.mockRejectedValueOnce(new Error("Failing final insert"));

    await expect(ProjectService.rollbackVersion(1, 999)).rejects.toThrow(
      "Failing final insert",
    );

    expect(pool.query).toHaveBeenCalledTimes(3);
  });

  test("rollbackVersion => if old version not found => throws 404 HttpError", async () => {
    pool.query.mockResolvedValueOnce({ rows: [] }); // no version found
    await expect(ProjectService.rollbackVersion(1, 9999)).rejects.toThrow(
      HttpError,
    ); // specifically 'Version not found.'

    expect(pool.query).toHaveBeenCalledTimes(1);
  });
});


===== ./tests/unit/messageDispatcher.test.js =====

// tests/unit/messageDispatcher.test.js

import { handleIncomingMessage } from "../../server/ws/messageDispatcher.js";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

// We’ll mock each handler we dispatch to:
import * as sessionHandlers from "../../server/ws/handlers/sessionHandlers.js";
import * as cursorHandlers from "../../server/ws/handlers/cursorHandlers.js";
import * as elementHandlers from "../../server/ws/handlers/elementHandlers.js";
import * as permissionHandlers from "../../server/ws/handlers/permissionHandlers.js";
import * as projectHandlers from "../../server/ws/handlers/projectHandlers.js";
import * as undoRedoHandlers from "../../server/ws/handlers/undoRedoHandlers.js";
import * as chatHandlers from "../../server/ws/handlers/chatHandlers.js";

jest.mock("../../server/ws/handlers/sessionHandlers.js");
jest.mock("../../server/ws/handlers/cursorHandlers.js");
jest.mock("../../server/ws/handlers/elementHandlers.js");
jest.mock("../../server/ws/handlers/permissionHandlers.js");
jest.mock("../../server/ws/handlers/projectHandlers.js");
jest.mock("../../server/ws/handlers/undoRedoHandlers.js");
jest.mock("../../server/ws/handlers/chatHandlers.js");

describe("messageDispatcher.js - handleIncomingMessage", () => {
  let mockSession, mockWs;

  beforeEach(() => {
    jest.clearAllMocks();
    mockSession = { code: "fake-session" };
    mockWs = { readyState: 1, send: jest.fn() };
  });

  test("handles JOIN_SESSION => handleJoinSession", () => {
    const data = { type: MESSAGE_TYPES.JOIN_SESSION };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(sessionHandlers.handleJoinSession).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles UPGRADE_USER_ID => handleUpgradeUserId", () => {
    const data = { type: MESSAGE_TYPES.UPGRADE_USER_ID };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(sessionHandlers.handleUpgradeUserId).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles CURSOR_UPDATE => handleCursorUpdate", () => {
    const data = { type: MESSAGE_TYPES.CURSOR_UPDATE };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(cursorHandlers.handleCursorUpdate).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles ELEMENT_MOVE => handleElementMove", () => {
    const data = { type: MESSAGE_TYPES.ELEMENT_MOVE };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(elementHandlers.handleElementMove).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles MAKE_EDITOR => handleMakeEditor", () => {
    const data = { type: MESSAGE_TYPES.MAKE_EDITOR };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(permissionHandlers.handleMakeEditor).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles PROJECT_NAME_CHANGE => handleProjectNameChange", () => {
    const data = { type: MESSAGE_TYPES.PROJECT_NAME_CHANGE };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(projectHandlers.handleProjectNameChange).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles UNDO => handleUndo", () => {
    const data = { type: MESSAGE_TYPES.UNDO };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(undoRedoHandlers.handleUndo).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles REDO => handleRedo", () => {
    const data = { type: MESSAGE_TYPES.REDO };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(undoRedoHandlers.handleRedo).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles CHAT_MESSAGE => handleChatMessage", () => {
    const data = { type: MESSAGE_TYPES.CHAT_MESSAGE };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(chatHandlers.handleChatMessage).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("handles DOWNGRADE_USER_ID => handleDowngradeUserId", () => {
    const data = { type: MESSAGE_TYPES.DOWNGRADE_USER_ID };
    handleIncomingMessage(mockSession, data, mockWs);
    expect(sessionHandlers.handleDowngradeUserId).toHaveBeenCalledWith(
      mockSession,
      data,
      mockWs,
    );
  });

  test("unknown message type => does nothing", () => {
    const data = { type: "some-unsupported-type" };
    handleIncomingMessage(mockSession, data, mockWs);
    // No calls
    expect(sessionHandlers.handleJoinSession).not.toHaveBeenCalled();
    expect(cursorHandlers.handleCursorUpdate).not.toHaveBeenCalled();
  });
});


===== ./tests/unit/AuthService.test.js =====

// tests/unit/AuthService.test.js
import { AuthService } from "../../server/services/AuthService.js";
import config from "../../server/config.js";
import jwt from "jsonwebtoken";

jest.mock("../../server/config.js", () => {
  return {
    __esModule: true,
    default: {
      JWT_SECRET: "test_secret_key",
    },
  };
});

describe("AuthService", () => {
  afterAll(() => {
    jest.restoreAllMocks();
  });

  test("userPayload returns a minimal payload object", () => {
    const mockUser = {
      id: 123,
      email: "user@example.com",
      role: "admin",
      name: "Alice",
      password: "hashed_pass",
    };

    const payload = AuthService.userPayload(mockUser);
    expect(payload).toEqual({
      id: 123,
      email: "user@example.com",
      role: "admin",
      name: "Alice",
      isAdmin: true,
    });
  });

  test("createToken creates a JWT string", () => {
    const payload = { id: 1, email: "test@example.com" };
    const token = AuthService.createToken(payload, "1h");
    expect(typeof token).toBe("string");
    // Basic check: it should have three parts separated by '.'
    const parts = token.split(".");
    expect(parts).toHaveLength(3);
  });

  test("verifyToken returns the decoded payload if valid", () => {
    const payload = { id: 999, email: "verify@test.com" };
    const token = AuthService.createToken(payload, "1h");

    // Should decode to the same data
    const decoded = AuthService.verifyToken(token);
    expect(decoded.id).toBe(999);
    expect(decoded.email).toBe("verify@test.com");
  });

  test("verifyToken throws error if invalid signature", () => {
    const payload = { foo: "bar" };
    const token = jwt.sign(payload, "some_other_secret"); // not using our test_secret_key

    expect(() => {
      AuthService.verifyToken(token);
    }).toThrow();
  });

  test("verifyToken throws error if token is expired", async () => {
    // A token that expires immediately
    const token = jwt.sign(
      { exp: Math.floor(Date.now() / 1000) - 1 },
      "test_secret_key",
    );
    expect(() => AuthService.verifyToken(token)).toThrow(/jwt expired/i);
  });
});


===== ./tests/unit/collaboration.test.js =====

// tests/unit/collaboration.test.js

import { handleWebSocketConnection } from "../../server/ws/collaboration.js";
import { SessionService } from "../../server/services/SessionService.js";
import {
  broadcastUserList,
  broadcastElementState,
} from "../../server/ws/collabUtils.js";
import { WebSocketServer } from "ws";

jest.mock("../../server/services/SessionService.js");
jest.mock("../../server/ws/collabUtils.js", () => ({
  broadcastUserList: jest.fn(),
  broadcastElementState: jest.fn(),
}));

describe("collaboration.js - handleWebSocketConnection", () => {
  let mockWss;
  let mockWs;

  beforeEach(() => {
    jest.clearAllMocks();

    mockWss = new WebSocketServer({ noServer: true });

    mockWs = {
      on: jest.fn(),
      send: jest.fn(),
      sessionCode: undefined,
      userId: undefined,
    };
  });

  test("attaches message and close handlers to the incoming ws", () => {
    handleWebSocketConnection(mockWs, mockWss);

    expect(mockWs.on).toHaveBeenCalledTimes(2);
    expect(mockWs.on).toHaveBeenCalledWith("message", expect.any(Function));
    expect(mockWs.on).toHaveBeenCalledWith("close", expect.any(Function));
  });

  test("if message is invalid JSON, it is ignored (no crash)", () => {
    handleWebSocketConnection(mockWs, mockWss);

    const onMessage = mockWs.on.mock.calls.find(
      ([evt]) => evt === "message",
    )[1];
    expect(() => onMessage("invalid json}")).not.toThrow();
  });

  test("on close: if no sessionCode or userId, does nothing", () => {
    handleWebSocketConnection(mockWs, mockWss);

    const closeHandler = mockWs.on.mock.calls.find(
      ([evt]) => evt === "close",
    )[1];
    closeHandler();

    expect(SessionService.getSession).not.toHaveBeenCalled();
    expect(broadcastUserList).not.toHaveBeenCalled();
    expect(broadcastElementState).not.toHaveBeenCalled();
  });

  test("on close: if session found, remove user, broadcast, possibly remove session", () => {
    mockWs.sessionCode = "test-session-code";
    mockWs.userId = "test-user";

    const mockSession = {
      code: "test-session-code",
      users: new Map([["test-user", { userId: "test-user" }]]),
      removeUser: jest.fn(),
      // We'll fake the user map size as 1
      usersSize: 1,
    };

    // Suppose after removeUser is called, there are 0 users left:
    mockSession.removeUser.mockImplementation((uid) => {
      mockSession.users.delete(uid);
    });

    SessionService.getSession.mockReturnValue(mockSession);

    handleWebSocketConnection(mockWs, mockWss);

    const closeHandler = mockWs.on.mock.calls.find(
      ([evt]) => evt === "close",
    )[1];
    closeHandler();

    expect(SessionService.getSession).toHaveBeenCalledWith("test-session-code");
    expect(mockSession.removeUser).toHaveBeenCalledWith("test-user");

    expect(broadcastUserList).toHaveBeenCalledWith(mockSession);
    expect(broadcastElementState).toHaveBeenCalledWith(mockSession);

    // Now that test-user is removed, the map is empty => session.users.size=0
    expect(SessionService.removeSession).toHaveBeenCalledWith(
      "test-session-code",
    );
  });
});


===== ./tests/integration/testUtils.js =====

// tests/integration/testUtils.js

import request from "supertest";
import app from "../../server/app.js";
import pool from "../../server/database.js";

/**
 * Creates a new user by calling POST /auth/register,
 * then optionally updates them to 'admin' in the DB
 * if { role: 'admin' } is requested.
 * Finally, re-logs in to retrieve a fresh token if needed.
 *
 * Returns an object: {
 *   token: string,
 *   userId: number,
 *   email: string,
 *   role: 'user' or 'admin'
 * }
 */
export async function createTestUser({
  name = "TestUser",
  email = `test_${Date.now()}@example.com`,
  password = "secret123",
  role = "user",
} = {}) {
  // Step 1: Register the user normally
  const reg = await request(app).post("/auth/register").send({
    name,
    email,
    password,
    confirmPassword: password,
  });

  if (reg.statusCode !== 201) {
    throw new Error(
      `Failed to register test user: ${reg.statusCode} => ${reg.body.message || reg.text}`,
    );
  }

  const { token, user } = reg.body;
  let finalToken = token;
  let finalRole = user.role; // typically 'user'

  // Step 2: If 'admin' role was requested, update the DB, then re-login
  if (role === "admin") {
    await pool.query("UPDATE users SET role=$1 WHERE id=$2", [
      "admin",
      user.id,
    ]);
    const reLogin = await request(app)
      .post("/auth/login")
      .send({ email, password });
    finalToken = reLogin.body.token;
    finalRole = "admin";
  }

  return {
    token: finalToken,
    userId: user.id,
    email,
    role: finalRole,
  };
}

/**
 * Call this afterAll to properly close the DB pool,
 * ensuring Jest does not hang waiting for open handles.
 */
export async function closeDBPool() {
  await pool.end();
}


===== ./tests/integration/wsCollaboration.test.js =====

// tests/integration/wsCollaboration.test.js

/**
 * ./tests/integration/wsCollaboration.test.js
 * This tests real-time collaboration over WS.
 *
 * We also close the DB pool in afterAll to avoid open handles.
 */
import { createServer } from "http";
import request from "supertest";
import { WebSocketServer } from "ws";
import WebSocket from "ws";
import app from "../../server/app.js";
import { handleWebSocketConnection } from "../../server/ws/collaboration.js";
import { closeDBPool } from "./testUtils.js";

jest.setTimeout(30000);

describe("WebSocket Collaboration Integration Test", () => {
  let server, wss, port;
  let client1, client2;
  let sessionCode;

  beforeAll((done) => {
    server = createServer(app);
    wss = new WebSocketServer({ server });
    wss.on("connection", (ws) => handleWebSocketConnection(ws, wss));
    server.listen(0, () => {
      port = server.address().port;
      // ephemeral session code
      sessionCode = `testWS_${Date.now()}`;
      done();
    });
  });

  afterAll(async () => {
    // Clean up websockets if still open
    if (client1 && client1.readyState === WebSocket.OPEN) client1.close();
    if (client2 && client2.readyState === WebSocket.OPEN) client2.close();
    server.close();

    // Also close DB pool
    await closeDBPool();
  });

  test("HTTP server is up => GET / responds 200", async () => {
    const res = await request(server).get("/");
    expect(res.statusCode).toBe(200);
    expect(res.text).toMatch(/<title>Board Game Prototyping<\/title>/);
  });

  test("Two WS clients => concurrency scenario", (done) => {
    const messagesClient1 = [];
    const messagesClient2 = [];

    client1 = new WebSocket(`ws://localhost:${port}`);
    client2 = new WebSocket(`ws://localhost:${port}`);

    function handleIncoming(wsName, msgStr, storage) {
      try {
        const data = JSON.parse(msgStr);
        storage.push(data);
      } catch (err) {
        console.error(wsName, "parse error:", err, msgStr);
      }
    }

    let step = 0;

    // Connect + join session
    client1.on("open", () => {
      client1.send(
        JSON.stringify({
          type: "join-session",
          userId: "testUser1",
          sessionCode,
          name: "UserOne",
          userRole: "admin",
        }),
      );
    });
    client2.on("open", () => {
      client2.send(
        JSON.stringify({
          type: "join-session",
          userId: "testUser2",
          sessionCode,
          name: "UserTwo",
          userRole: "admin",
        }),
      );
    });

    client1.on("message", (raw) => {
      handleIncoming("client1", raw, messagesClient1);
      proceedIfReady();
    });
    client2.on("message", (raw) => {
      handleIncoming("client2", raw, messagesClient2);
      proceedIfReady();
    });

    function lockedBy(msg, elementId, locker) {
      return (
        msg.type === "element-state" &&
        msg.elements?.some((e) => e.id === elementId && e.lockedBy === locker)
      );
    }

    function atPosition(msg, elementId, x, y) {
      return (
        msg.type === "element-state" &&
        msg.elements?.some((e) => e.id === elementId && e.x === x && e.y === y)
      );
    }

    function lastElemState(msgs) {
      return [...msgs].reverse().find((m) => m.type === "element-state");
    }

    function proceedIfReady() {
      if (step === 0) {
        // Wait until each client has at least 2 inbound messages
        if (messagesClient1.length >= 2 && messagesClient2.length >= 2) {
          step = 1;
          client1.send(
            JSON.stringify({
              type: "element-grab",
              userId: "testUser1",
              elementId: 1,
            }),
          );
        }
      } else if (step === 1) {
        // Wait for both to see lockedBy='testUser1' for element #1
        const c1HasLock = messagesClient1.some((m) =>
          lockedBy(m, 1, "testUser1"),
        );
        const c2HasLock = messagesClient2.some((m) =>
          lockedBy(m, 1, "testUser1"),
        );
        if (c1HasLock && c2HasLock) {
          step = 2;
          // Move the locked element to (500,300)
          client1.send(
            JSON.stringify({
              type: "element-move",
              userId: "testUser1",
              elementId: 1,
              x: 500,
              y: 300,
            }),
          );
        }
      } else if (step === 2) {
        // Wait until each sees element #1 at (500,300)
        const c1HasMove = messagesClient1.some((m) =>
          atPosition(m, 1, 500, 300),
        );
        const c2HasMove = messagesClient2.some((m) =>
          atPosition(m, 1, 500, 300),
        );
        if (c1HasMove && c2HasMove) {
          step = 3;
          // user2 tries to move same => locked => ignore
          client2.send(
            JSON.stringify({
              type: "element-move",
              userId: "testUser2",
              elementId: 1,
              x: 999,
              y: 999,
            }),
          );
          // No new broadcast from server expected => finalize
          setTimeout(() => {
            const lastStateC2 = lastElemState(messagesClient2);
            if (lastStateC2) {
              const el = lastStateC2.elements.find((e) => e.id === 1);
              expect(el.x).toBe(500);
              expect(el.y).toBe(300);
            }
            done();
          }, 200);
        }
      }
    }
  });
});


===== ./tests/integration/edgeCases.test.js =====

// tests/integration/edgeCases.test.js

import request from "supertest";
import app from "../../server/app.js";
import { createTestUser, closeDBPool } from "./testUtils.js";

describe("Edge Cases Integration Tests", () => {
  let token;

  beforeAll(async () => {
    // Create a user to test with
    const user = await createTestUser({ name: "EdgeTester" });
    token = user.token;
  });

  afterAll(async () => {
    await closeDBPool();
  });

  test("Creating a project with missing name => uses fallback or fails gracefully", async () => {
    const res = await request(app)
      .post("/projects")
      .set("Authorization", `Bearer ${token}`)
      .send({ description: "No name provided" });
    // If your route requires name strictly, expect 400
    // else if it sets a default name, expect 201 or similar
    // We'll just check for not 500:
    expect([400, 201]).toContain(res.statusCode);
  });

  test("Requesting a non-existent project => 403 or 404 when user is not owner/admin", async () => {
    const getRes = await request(app)
      .get("/projects/99999999") // presumably doesn't exist
      .set("Authorization", `Bearer ${token}`);
    expect([403, 404]).toContain(getRes.statusCode);
  });

  test("Register with a duplicate email => 400 or 409", async () => {
    // Use a unique "duplicate" email each time so the first registration always succeeds
    const uniqueEmail = `edge_dup_${Date.now()}@example.com`;
    const existing = await createTestUser({ email: uniqueEmail });

    const dup = await request(app).post("/auth/register").send({
      name: "DupUser",
      email: uniqueEmail,
      password: "pass123",
      confirmPassword: "pass123",
    });
    expect([400, 409]).toContain(dup.statusCode);
  });
});


===== ./tests/integration/errorAndNotFound.test.js =====

// tests/integration/errorAndNotFound.test.js

import request from "supertest";
import app from "../../server/app.js";
import { closeDBPool } from "./testUtils.js";

describe("Error & Not Found Integration Tests", () => {
  // Add ephemeral route for forced error
  beforeAll(() => {
    app.get("/test/throw-error", (req, res) => {
      throw new Error("Test forced error");
    });
  });

  afterAll(async () => {
    await closeDBPool();
  });

  test("GET /nonexistent-route => 404 Not Found", async () => {
    const res = await request(app).get("/this-route-does-not-exist");
    expect(res.status).toBe(404);
    // By default, Express might respond with "Cannot GET /..."
    // or your custom 404 handler might produce JSON
  });

  test("GET /test/throw-error => triggers global error handler => 500", async () => {
    const res = await request(app).get("/test/throw-error");
    expect(res.status).toBe(500);
    expect(res.body).toHaveProperty("message", "Test forced error");
  });
});


===== ./tests/integration/authRoutes.test.js =====

// tests/integration/authRoutes.test.js

import request from "supertest";
import app from "../../server/app.js";
import { closeDBPool } from "./testUtils.js";

describe("Auth Routes Integration", () => {
  afterAll(async () => {
    await closeDBPool();
  });

  test("POST /auth/register with missing fields => 400", async () => {
    const res = await request(app).post("/auth/register").send({});
    expect(res.statusCode).toBe(400);
    expect(res.body).toHaveProperty("message");
  });

  test("POST /auth/register with valid data => 201 & token", async () => {
    const uniqueEmail = `test_${Date.now()}@example.com`;
    const res = await request(app).post("/auth/register").send({
      name: "TestUser",
      email: uniqueEmail,
      password: "secret123",
      confirmPassword: "secret123",
    });
    expect(res.statusCode).toBe(201);
    expect(res.body).toHaveProperty("token");
    expect(res.body.user.email).toBe(uniqueEmail);
  });

  test("POST /auth/login with wrong password => 401", async () => {
    const res = await request(app)
      .post("/auth/login")
      .send({ email: "no-such-user@example.com", password: "wrongpass" });
    expect(res.statusCode).toBe(401);
    expect(res.body).toHaveProperty("message", "Invalid credentials.");
  });
});


===== ./tests/integration/adminRoutes.test.js =====

// tests/integration/adminRoutes.test.js

import request from "supertest";
import app from "../../server/app.js";
// We remove direct "pool" import and use closeDBPool() instead
import { createTestUser, closeDBPool } from "./testUtils.js";

/**
 * Integration tests for admin routes
 *   - GET /admin/users
 *   - PUT /admin/users/:id/role
 *   - DELETE /admin/users/:id
 */
describe("Admin Routes Integration", () => {
  let adminToken;
  let regularToken;
  let testUserId;

  beforeAll(async () => {
    // 1) Create an admin user
    const admin = await createTestUser({ role: "admin", name: "AdminTest" });
    adminToken = admin.token;

    // 2) Create a regular user
    const regular = await createTestUser({ name: "RegularUser" });
    regularToken = regular.token;
    testUserId = regular.userId;
  });

  afterAll(async () => {
    // Clean up DB connections
    await closeDBPool();
  });

  test("GET /admin/users requires admin token", async () => {
    // With regular user token => should fail
    const res1 = await request(app)
      .get("/admin/users")
      .set("Authorization", `Bearer ${regularToken}`);
    expect(res1.statusCode).toBe(403);
    expect(res1.body).toHaveProperty("message", "Access denied. Admins only.");

    // With admin token => success
    const res2 = await request(app)
      .get("/admin/users")
      .set("Authorization", `Bearer ${adminToken}`);
    expect(res2.statusCode).toBe(200);
    expect(Array.isArray(res2.body)).toBe(true);
  });

  test("PUT /admin/users/:id/role => update user role", async () => {
    // Attempt as regular => fail
    const res1 = await request(app)
      .put(`/admin/users/${testUserId}/role`)
      .set("Authorization", `Bearer ${regularToken}`)
      .send({ role: "admin" });
    expect(res1.statusCode).toBe(403);

    // Attempt as admin => success
    const res2 = await request(app)
      .put(`/admin/users/${testUserId}/role`)
      .set("Authorization", `Bearer ${adminToken}`)
      .send({ role: "admin" });
    expect(res2.statusCode).toBe(200);
    expect(res2.body).toHaveProperty("role", "admin");
  });

  test("DELETE /admin/users/:id => remove user from DB", async () => {
    // First, create a temp user
    const temp = await createTestUser({ name: "TempUserToDelete" });
    const tempId = temp.userId;

    // Try to delete as a regular user => fail
    const delFail = await request(app)
      .delete(`/admin/users/${tempId}`)
      .set("Authorization", `Bearer ${regularToken}`);
    expect(delFail.statusCode).toBe(403);

    // Delete as admin => success
    const delOk = await request(app)
      .delete(`/admin/users/${tempId}`)
      .set("Authorization", `Bearer ${adminToken}`);
    expect(delOk.statusCode).toBe(200);
    expect(delOk.body).toHaveProperty("message", "User deleted");
  });
});


===== ./tests/integration/projectRoutes.test.js =====

// tests/integration/projectRoutes.test.js

import request from "supertest";
import app from "../../server/app.js";
import { createTestUser, closeDBPool } from "./testUtils.js";

describe("Project Routes Integration (Two-Project Technique)", () => {
  let user1Token, user1Id;
  let user2Token, user2Id;
  let adminToken, adminId;

  let projectA; // for user1's normal flow
  let projectB; // for admin override tests

  beforeAll(async () => {
    // 1) Create User1 (owner)
    const user1 = await createTestUser({ name: "UserOneOwner" });
    user1Token = user1.token;
    user1Id = user1.userId;

    // 2) Create User2 (non-owner)
    const user2 = await createTestUser({ name: "UserTwoThief" });
    user2Token = user2.token;
    user2Id = user2.userId;

    // 3) Create admin user
    const adminUser = await createTestUser({
      role: "admin",
      name: "UserThreeAdmin",
    });
    adminToken = adminUser.token;
    adminId = adminUser.userId;
  });

  afterAll(async () => {
    await closeDBPool();
  });

  // PART A
  test("User1 creates Project A => 201", async () => {
    const createRes = await request(app)
      .post("/projects")
      .set("Authorization", `Bearer ${user1Token}`)
      .send({
        name: "Project A",
        description: "For user1 testing",
      });
    expect(createRes.statusCode).toBe(201);
    projectA = createRes.body.id;
  });

  describe("User2 tries to access Project A => 403", () => {
    test("User2 tries to update => 403", async () => {
      const res = await request(app)
        .put(`/projects/${projectA}`)
        .set("Authorization", `Bearer ${user2Token}`)
        .send({ name: "HackedName" });
      expect(res.statusCode).toBe(403);
    });

    test("User2 tries to delete => 403", async () => {
      const del = await request(app)
        .delete(`/projects/${projectA}`)
        .set("Authorization", `Bearer ${user2Token}`);
      expect(del.statusCode).toBe(403);
    });
  });

  test("User1 updates Project A => 200", async () => {
    const res = await request(app)
      .put(`/projects/${projectA}`)
      .set("Authorization", `Bearer ${user1Token}`)
      .send({
        name: "My Updated Project A",
        description: "Changed desc A",
      });
    expect(res.statusCode).toBe(200);
    expect(res.body.name).toBe("My Updated Project A");
  });

  test("User1 lists versions of Project A => initially none => 200", async () => {
    const versionsRes = await request(app)
      .get(`/projects/${projectA}/versions`)
      .set("Authorization", `Bearer ${user1Token}`);
    expect(versionsRes.statusCode).toBe(200);
    expect(Array.isArray(versionsRes.body)).toBe(true);
    expect(versionsRes.body.length).toBe(0);
  });

  test("User1 creates version on Project A => 201", async () => {
    const payload = { project_data: { someKey: "someValueA" } };
    const verRes = await request(app)
      .post(`/projects/${projectA}/versions`)
      .set("Authorization", `Bearer ${user1Token}`)
      .send(payload);
    expect(verRes.statusCode).toBe(201);
    expect(verRes.body.version_number).toBe(1);
  });

  test("User1 deletes Project A => 200", async () => {
    const del = await request(app)
      .delete(`/projects/${projectA}`)
      .set("Authorization", `Bearer ${user1Token}`);
    expect(del.statusCode).toBe(200);
    expect(del.body).toHaveProperty("message", "Project deleted");
  });

  // PART B
  test("User1 creates Project B => 201", async () => {
    const createB = await request(app)
      .post("/projects")
      .set("Authorization", `Bearer ${user1Token}`)
      .send({
        name: "Project B",
        description: "For admin override tests",
      });
    expect(createB.statusCode).toBe(201);
    projectB = createB.body.id;
  });

  test("Admin forcibly updates Project B => 200", async () => {
    const res = await request(app)
      .put(`/projects/${projectB}`)
      .set("Authorization", `Bearer ${adminToken}`)
      .send({
        name: "Admin Overrode B",
        description: "Admin changed B desc",
      });
    expect(res.statusCode).toBe(200);
    expect(res.body.id).toBe(projectB);
    expect(res.body.name).toBe("Admin Overrode B");
  });

  test("Admin forcibly deletes Project B => 200", async () => {
    const del = await request(app)
      .delete(`/projects/${projectB}`)
      .set("Authorization", `Bearer ${adminToken}`);
    expect(del.statusCode).toBe(200);
    expect(del.body).toHaveProperty("message", "Project deleted");
  });

  // PART C
  describe("GET /projects/ensureDefault => ensures at least one project", () => {
    let defaultProjectId = null;

    test("returns 401 if not logged in", async () => {
      const res = await request(app).get("/projects/ensureDefault");
      expect(res.statusCode).toBe(401);
    });

    test("when user1 has no projects, returns a new default => 200", async () => {
      const res = await request(app)
        .get("/projects/ensureDefault")
        .set("Authorization", `Bearer ${user1Token}`);
      expect(res.statusCode).toBe(200);
      expect(res.body).toHaveProperty("id");
      defaultProjectId = res.body.id;
    });

    test("calling again returns the same default => 200", async () => {
      const res2 = await request(app)
        .get("/projects/ensureDefault")
        .set("Authorization", `Bearer ${user1Token}`);
      expect(res2.statusCode).toBe(200);
      expect(res2.body.id).toBe(defaultProjectId);
    });
  });
});


===== ./tests/integration/serverStartup.test.js =====

// tests/integration/serverStartup.test.js

import request from "supertest";
import { createServer } from "http";
import { WebSocketServer } from "ws";
import app from "../../server/app.js";
import { handleWebSocketConnection } from "../../server/ws/collaboration.js";
import { closeDBPool } from "./testUtils.js";

describe("Server Startup Integration Test", () => {
  let server;

  beforeAll((done) => {
    server = createServer(app);
    const wss = new WebSocketServer({ server });
    wss.on("connection", (ws) => handleWebSocketConnection(ws, wss));
    server.listen(0, done);
  });

  afterAll(async () => {
    server.close();
    await closeDBPool();
  });

  test("responds with HTML at /", async () => {
    const res = await request(server).get("/");
    expect(res.statusCode).toBe(200);
    expect(res.text).toMatch(/<title>Board Game Prototyping<\/title>/);
  });
});


===== ./tests/client/canvas.test.js =====

/**
 * @jest-environment jsdom
 */
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";
import {
  initCanvas,
  handleCanvasMessage,
  updateCanvasUserId,
} from "../../client/js/canvas.js";
import * as wsClient from "../../client/js/wsClient.js";

// 1) Import the shared state from the canvas so we can reset it:
import { state } from "../../client/js/canvas/canvasState.js";

jest.mock("../../client/js/wsClient.js", () => ({
  sendWSMessage: jest.fn(),
}));

// Polyfill PointerEvent if not present
if (typeof PointerEvent === "undefined") {
  class PointerEventFake extends MouseEvent {
    constructor(type, params = {}) {
      super(type, params);
      this.pointerId = params.pointerId ?? 1;
      this.pointerType = params.pointerType ?? "mouse";
      this.isPrimary = params.isPrimary ?? true;
    }
  }
  global.PointerEvent = PointerEventFake;
}

function dispatchPointerEvent(target, type, opts = {}) {
  const event = new PointerEvent(type, {
    bubbles: true,
    cancelable: true,
    clientX: 0,
    clientY: 0,
    pointerId: 1,
    pointerType: "mouse",
    button: 0,
    buttons: 1,
    shiftKey: false,
    ...opts,
  });
  target.dispatchEvent(event);
}

describe("canvas.js front-end logic with pointer-event polyfill", () => {
  let canvas;

  beforeAll(() => {
    // Polyfill setPointerCapture / releasePointerCapture
    Object.defineProperty(HTMLCanvasElement.prototype, "setPointerCapture", {
      value: () => {},
      configurable: true,
    });
    Object.defineProperty(
      HTMLCanvasElement.prototype,
      "releasePointerCapture",
      {
        value: () => {},
        configurable: true,
      },
    );

    // Provide stable bounding rect
    Object.defineProperty(
      HTMLCanvasElement.prototype,
      "getBoundingClientRect",
      {
        value: () => ({ left: 0, top: 0, width: 800, height: 600 }),
        configurable: true,
      },
    );

    global.devicePixelRatio = 1;
  });

  beforeEach(() => {
    // 2) Reset relevant state fields so leftover data doesn't cause NaN or weird coords
    state.camX = 0;
    state.camY = 0;
    state.scale = 1;
    state.elements = [];
    state.selectedElementIds = [];
    state.isPanning = false;
    state.isDragging = false;
    state.isResizing = false;
    // Clear calls
    wsClient.sendWSMessage.mockClear();

    document.body.innerHTML = `
      <canvas id="gameCanvas" width="800" height="600"></canvas>
      <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
        <button id="frame-all">Frame</button>
        <span id="zoom-level">100%</span>
      </div>
      <div id="tools-palette">
        <button data-tool="select" class="tool-btn selected">Select</button>
        <button data-tool="rectangle" class="tool-btn">Rectangle</button>
      </div>
    `;
    canvas = document.getElementById("gameCanvas");
    initCanvas("testUser");
  });

  afterAll(() => {
    delete global.devicePixelRatio;
  });

  test("panning with right mouse button emits no element-based messages", () => {
    dispatchPointerEvent(canvas, "pointerdown", {
      clientX: 100,
      clientY: 100,
      button: 2,
      buttons: 2,
    });
    dispatchPointerEvent(canvas, "pointermove", {
      clientX: 120,
      clientY: 120,
      button: 2,
      buttons: 2,
    });
    dispatchPointerEvent(canvas, "pointerup", {
      clientX: 120,
      clientY: 120,
      button: 2,
      buttons: 0,
    });

    const nonCursor = wsClient.sendWSMessage.mock.calls.filter(
      ([msg]) =>
        ![MESSAGE_TYPES.CURSOR_UPDATE, MESSAGE_TYPES.CURSOR_UPDATES].includes(
          msg.type,
        ),
    );
    expect(nonCursor).toHaveLength(0);
  });

  test("selecting an existing shape triggers ELEMENT_GRAB", () => {
    handleCanvasMessage(
      {
        type: MESSAGE_TYPES.ELEMENT_STATE,
        elements: [
          {
            id: 1,
            x: 0,
            y: 0,
            w: 400,
            h: 400,
            lockedBy: null,
            shape: "rectangle",
          },
        ],
      },
      "testUser",
    );

    dispatchPointerEvent(canvas, "pointerdown", {
      clientX: 50,
      clientY: 50,
      button: 0,
      buttons: 1,
    });
    dispatchPointerEvent(canvas, "pointerup", {
      clientX: 50,
      clientY: 50,
      button: 0,
      buttons: 0,
    });

    const grabMsg = wsClient.sendWSMessage.mock.calls.find(
      ([msg]) => msg.type === MESSAGE_TYPES.ELEMENT_GRAB,
    );
    expect(grabMsg).toBeTruthy();
    expect(grabMsg[0]).toMatchObject({
      type: MESSAGE_TYPES.ELEMENT_GRAB,
      elementId: 1,
      userId: "testUser",
    });
  });

  test("dragging a selected shape calls ELEMENT_MOVE (after shape is locked)", () => {
    // 1) Insert shape #10
    handleCanvasMessage(
      {
        type: MESSAGE_TYPES.ELEMENT_STATE,
        elements: [
          {
            id: 10,
            x: 0,
            y: 0,
            w: 400,
            h: 400,
            lockedBy: null,
            shape: "rectangle",
          },
        ],
      },
      "testUser",
    );

    // pointerDown->pointerUp => triggers GRAB
    dispatchPointerEvent(canvas, "pointerdown", {
      clientX: 60,
      clientY: 60,
      button: 0,
      buttons: 1,
    });
    dispatchPointerEvent(canvas, "pointerup", {
      clientX: 60,
      clientY: 60,
      button: 0,
      buttons: 0,
    });
    const grabCall = wsClient.sendWSMessage.mock.calls.find(
      ([m]) => m.type === MESSAGE_TYPES.ELEMENT_GRAB,
    );
    expect(grabCall).toBeTruthy();

    // 2) Fake server => shape locked by testUser
    handleCanvasMessage(
      {
        type: MESSAGE_TYPES.ELEMENT_STATE,
        elements: [
          {
            id: 10,
            x: 0,
            y: 0,
            w: 400,
            h: 400,
            lockedBy: "testUser",
            shape: "rectangle",
          },
        ],
      },
      "testUser",
    );

    wsClient.sendWSMessage.mockClear();

    // 3) pointerDown again => now we start the actual drag
    dispatchPointerEvent(canvas, "pointerdown", {
      clientX: 60,
      clientY: 60,
      button: 0,
      buttons: 1,
    });
    // pointerMove => from (60,60) to (120,80)
    dispatchPointerEvent(canvas, "pointermove", {
      clientX: 120,
      clientY: 80,
      button: 0,
      buttons: 1,
    });
    // pointerUp => finalize
    dispatchPointerEvent(canvas, "pointerup", {
      clientX: 120,
      clientY: 80,
      button: 0,
      buttons: 0,
    });

    const allCalls = wsClient.sendWSMessage.mock.calls;
    console.log("All calls =>", allCalls);

    // Expect an ELEMENT_MOVE
    const moveMsg = allCalls.find(
      ([m]) => m.type === MESSAGE_TYPES.ELEMENT_MOVE,
    );
    expect(moveMsg).toBeTruthy();
    expect(moveMsg[0]).toMatchObject({
      type: MESSAGE_TYPES.ELEMENT_MOVE,
      elementId: 10,
      userId: "testUser",
    });
  });

  test("updating local user ID changes subsequent messages", () => {
    handleCanvasMessage(
      {
        type: MESSAGE_TYPES.ELEMENT_STATE,
        elements: [
          {
            id: 99,
            x: 0,
            y: 0,
            w: 800,
            h: 600,
            lockedBy: null,
            shape: "rectangle",
          },
        ],
      },
      "testUser",
    );

    updateCanvasUserId("someOtherUser");
    dispatchPointerEvent(canvas, "pointerdown", {
      clientX: 100,
      clientY: 100,
      button: 0,
      buttons: 1,
    });
    dispatchPointerEvent(canvas, "pointerup", {
      clientX: 100,
      clientY: 100,
      button: 0,
      buttons: 0,
    });

    const realCall = wsClient.sendWSMessage.mock.calls.find(
      ([m]) => m.type === MESSAGE_TYPES.ELEMENT_GRAB,
    );
    expect(realCall).toBeTruthy();
    expect(realCall[0].userId).toBe("someOtherUser");
  });
});


===== ./server/database.js =====

// server/database.js
import pkg from "pg";
const { Pool } = pkg;
import config from "./config.js";

const pool = new Pool({
  user: config.DB_USER,
  host: config.DB_HOST,
  database: config.DB_NAME,
  password: config.DB_PASSWORD,
  port: config.DB_PORT,
  ssl: config.DB_SSL ? { rejectUnauthorized: false } : false,
});

export const connectDB = async () => {
  try {
    await pool.query("SELECT 1");
    console.log("Connected to PostgreSQL database");
  } catch (error) {
    console.error("Database connection error:", error);
    process.exit(1);
  }
};

export default pool;


===== ./server/index.js =====

// server/index.js
import http from "http";
import { WebSocketServer } from "ws";
import app from "./app.js";
import { handleWebSocketConnection } from "./ws/collaboration.js";
import config from "./config.js";

// Create an HTTP server from the Express app
const server = http.createServer(app);

// Create a WebSocket server on top of the same HTTP server
const wss = new WebSocketServer({ server });

// Handle new WebSocket connections
wss.on("connection", (ws) => handleWebSocketConnection(ws, wss));

// Finally, start listening on the configured port
server.listen(config.PORT, () => {
  console.log(`Server running on port ${config.PORT}`);
});


===== ./server/config.js =====

// server/config.js
import dotenv from "dotenv";

// Load environment variables once
dotenv.config();

const isTestEnv = process.env.NODE_ENV === "test";

// Conditionally choose DB name:
const dbName = isTestEnv
  ? "board_game_prototyping_test"
  : process.env.DB_NAME || "board_game_prototyping";

const config = {
  PORT: process.env.PORT || 3000,
  DB_USER: process.env.DB_USER || "postgres",
  DB_HOST: process.env.DB_HOST || "db",
  DB_NAME: dbName,
  DB_PASSWORD: process.env.DB_PASSWORD || "postgrespassword",
  DB_PORT: process.env.DB_PORT || "5432",
  DB_SSL: process.env.DB_SSL === "true",
  JWT_SECRET: process.env.JWT_SECRET || "your_jwt_secret",
  NODE_ENV: process.env.NODE_ENV || "development",
};

export default config;


===== ./server/app.js =====

// server/app.js
import express from "express";
import cors from "cors";
import path from "path";
import authRoutes from "./routes/auth.js";
import projectRoutes from "./routes/projects.js";
import config from "./config.js";
import adminRoutes from "./routes/admin.js";

/**
 * Instead of import.meta.url + fileURLToPath, we'll use process.cwd() or
 * a known relative path from the project root. This is simpler for Node + Babel.
 *
 * If your 'client' folder is in the project root, then process.cwd() will
 * typically be the root when you run 'npm start', so this resolves correctly.
 * Adjust the path if your structure differs or if you run the app from a subfolder.
 */
const ROOT_DIR = process.cwd();
// or, if needed, you can do something like:
// const ROOT_DIR = path.resolve(__dirname, '../..'); // if you prefer

const app = express();

app.use(express.json());
app.use(cors({ origin: "*" }));

// Serve static frontend files from /client relative to the project root
app.use(express.static(path.join(ROOT_DIR, "client")));

// If you have a /shared folder:
app.use("/shared", express.static(path.join(ROOT_DIR, "shared")));

// API Routes
app.use("/auth", authRoutes);
app.use("/projects", projectRoutes);
app.use("/admin", adminRoutes);

// Serve index.html for root (assuming /client/index.html exists)
app.get("/", (req, res) => {
  res.sendFile(path.join(ROOT_DIR, "client", "index.html"));
});

// near the bottom, before your global error handler:
if (process.env.NODE_ENV === "test") {
  app.get("/test/throw-error", (req, res) => {
    throw new Error("Test forced error");
  });
}

// Global error handler
app.use((err, req, res, next) => {
  console.error("Global Error Handler:", err.stack || err);
  const status = err.statusCode || 500;
  const msg = err.message || "Server Error";
  res.status(status).json({ message: msg });
});

export default app;


===== ./server/middleware/authMiddleware.js =====

// =========================
// FILE: server/middleware/authMiddleware.js
// =========================

import { AuthService } from "../services/AuthService.js";

/**
 * authenticateToken
 *  - If no token => 401, if invalid => 403,
 *  - else sets req.user and calls next().
 */
export const authenticateToken = (req, res, next) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    // Your unit test expects res.status(401)
    res.status(401).json({ message: "Unauthorized: No token provided" });
    return;
  }

  try {
    const user = AuthService.verifyToken(token);
    req.user = user;
    next();
  } catch (err) {
    // Your unit test expects res.status(403)
    res.status(403).json({ message: "Forbidden: Invalid token" });
  }
};

/**
 * authorizeAdmin
 *  - If req.user.isAdmin is not true => 403
 *  - else next()
 */
export const authorizeAdmin = (req, res, next) => {
  if (req.user && req.user.isAdmin) {
    return next();
  }
  // Again, your test expects direct res calls
  res.status(403).json({ message: "Access denied. Admins only." });
};


===== ./server/utils/asyncHandler.js =====

// server/utils/asyncHandler.js

/**
 * A higher-order function to wrap async route handlers,
 * automatically passing errors to next() for the global error handler.
 */

export function asyncHandler(fn) {
  return function (req, res, next) {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}


===== ./server/utils/HttpError.js =====

// ./server/utils/HttpError.js
export class HttpError extends Error {
  constructor(message, statusCode = 500) {
    super(message);
    this.statusCode = statusCode;
    this.name = "HttpError";

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}


===== ./server/utils/Permissions.js =====

// server/utils/Permissions.js

/**
 * We unify how we check "isAdmin", "isOwner", etc.
 * In the ephemeral session user object, we now store:
 *   user.globalRole = 'admin' | 'user'
 *   user.sessionRole = 'owner' | 'editor' | 'viewer'
 *
 * isAdmin is determined by user.globalRole === 'admin'.
 * isOwner is sessionRole === 'owner'.
 * isEditor is sessionRole === 'editor' OR 'owner' (owner implicitly can edit).
 */

export function isAdmin(user) {
  return user.globalRole === "admin";
}

export function isOwner(user) {
  return user.sessionRole === "owner";
}

export function isEditor(user) {
  // Let's treat "owner" as at least "editor" level in session
  return user.sessionRole === "editor" || user.sessionRole === "owner";
}

export function isViewer(user) {
  return user.sessionRole === "viewer";
}

/**
 * canManageOthers => global admin or session owner
 */
export function canManageOthers(user) {
  return isAdmin(user) || isOwner(user);
}

/**
 * canKickUser => only if kicker canManage, and target is not an admin or owner
 */
export function canKickUser(kicker, target) {
  if (!canManageOthers(kicker)) return false;
  if (isAdmin(target)) return false;
  if (isOwner(target)) return false;
  return true;
}

/**
 * canRenameProject => if user is admin or session owner
 */
export function canRenameProject(user) {
  return canManageOthers(user);
}

/**
 * canEditProject => if user is admin or session owner or session editor
 */
export function canEditProject(user) {
  // For ephemeral session-based editing, we interpret "editor" as well
  // But you can customize as you see fit.
  return isAdmin(user) || isOwner(user) || isEditor(user);
}


===== ./server/routes/auth.js =====

// =========================
// FILE: server/routes/auth.js
// =========================

import express from "express";
import { asyncHandler } from "../utils/asyncHandler.js";
import { HttpError } from "../utils/HttpError.js";
import { UserService } from "../services/UserService.js";
import { AuthService } from "../services/AuthService.js";

const router = express.Router();

/**
 * POST /auth/register
 * Body: { name, email, password, confirmPassword }
 */
router.post(
  "/register",
  asyncHandler(async (req, res) => {
    const { name, email, password, confirmPassword } = req.body;
    if (!name || !email || !password || !confirmPassword) {
      throw new HttpError("All fields are required.", 400);
    }
    if (password !== confirmPassword) {
      throw new HttpError("Passwords do not match.", 400);
    }

    const user = await UserService.createUser(name, email, password);
    const payload = AuthService.userPayload(user);
    const token = AuthService.createToken(payload, "1h");

    return res.status(201).json({
      message: "User registered successfully",
      user,
      token,
    });
  }),
);

/**
 * POST /auth/login
 * Body: { email, password }
 */
router.post(
  "/login",
  asyncHandler(async (req, res) => {
    const { email, password } = req.body;
    const user = await UserService.getByEmail(email);
    if (!user) {
      // 401 => invalid credentials
      throw new HttpError("Invalid credentials.", 401);
    }

    const isMatch = await UserService.comparePasswords(password, user.password);
    if (!isMatch) {
      throw new HttpError("Invalid credentials.", 401);
    }

    // Build & sign JWT
    const payload = AuthService.userPayload(user);
    const token = AuthService.createToken(payload, "1h");

    return res.json({
      message: "Logged in successfully",
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
      },
      token,
    });
  }),
);

export default router;


===== ./server/routes/projects.js =====

// =========================
// FILE: server/routes/projects.js
// =========================

import express from "express";
import { authenticateToken } from "../middleware/authMiddleware.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { HttpError } from "../utils/HttpError.js";
import { ProjectService } from "../services/ProjectService.js";
import { SessionService } from "../services/SessionService.js";

const router = express.Router();

/**
 * checkProjectEditorPermission => if user can't edit, throw 403 or project not found => 404
 */
async function checkProjectEditorPermission(req, res, next) {
  const { id } = req.params; // project id
  const canEdit = await ProjectService.userCanEditProject(id, req.user);
  if (!canEdit) {
    throw new HttpError("Not authorized or project not found.", 403);
  }
  return next();
}

/**
 * GET /projects/ensureDefault
 */
router.get(
  "/ensureDefault",
  authenticateToken,
  asyncHandler(async (req, res) => {
    const project = await ProjectService.createDefaultProjectIfNone(
      req.user.id,
    );
    return res.json(project);
  }),
);

/**
 * POST /projects
 */
router.post(
  "/",
  authenticateToken,
  asyncHandler(async (req, res) => {
    const { name, description } = req.body;
    if (!req.user || !req.user.id) {
      throw new HttpError("User ID is missing from request", 400);
    }
    if (!name) {
      throw new HttpError("Project name is required", 400);
    }

    const project = await ProjectService.createProject(
      req.user.id,
      name,
      description,
    );
    return res.status(201).json(project);
  }),
);

/**
 * GET /projects
 */
router.get(
  "/",
  authenticateToken,
  asyncHandler(async (req, res) => {
    const projects = await ProjectService.getProjectsByOwner(req.user.id);
    return res.json(projects);
  }),
);

/**
 * PUT /projects/:id
 */
router.put(
  "/:id",
  authenticateToken,
  asyncHandler(checkProjectEditorPermission),
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    let { name, description } = req.body;
    if (!description) description = "";

    const updated = await ProjectService.updateProject(id, name, description);
    if (!updated) {
      throw new HttpError("Project not found", 404);
    }
    return res.json(updated);
  }),
);

/**
 * DELETE /projects/:id
 */
router.delete(
  "/:id",
  authenticateToken,
  asyncHandler(checkProjectEditorPermission),
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const deleted = await ProjectService.deleteProject(id);
    if (!deleted) {
      throw new HttpError("Project not found", 404);
    }
    return res.json({ message: "Project deleted" });
  }),
);

/**
 * GET /projects/:id/versions
 */
router.get(
  "/:id/versions",
  authenticateToken,
  asyncHandler(checkProjectEditorPermission),
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const versions = await ProjectService.listVersions(id);
    return res.json(versions);
  }),
);

/**
 * POST /projects/:id/versions
 */
router.post(
  "/:id/versions",
  authenticateToken,
  asyncHandler(checkProjectEditorPermission),
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { project_data } = req.body || {};

    const newVersion = await ProjectService.createVersion(id, project_data);

    const session = SessionService.getSession(`project_${id}`);
    if (session) {
      SessionService.clearUndoRedo(session);
    }
    return res.status(201).json(newVersion);
  }),
);

/**
 * POST /projects/:id/versions/:versionId/rollback
 */
router.post(
  "/:id/versions/:versionId/rollback",
  authenticateToken,
  asyncHandler(checkProjectEditorPermission),
  asyncHandler(async (req, res) => {
    const { id, versionId } = req.params;
    const result = await ProjectService.rollbackVersion(id, versionId);

    const session = SessionService.getSession(`project_${id}`);
    if (session) {
      SessionService.clearUndoRedo(session);
    }
    return res.json(result);
  }),
);

export default router;


===== ./server/routes/admin.js =====

// =========================
// FILE: server/routes/admin.js
// =========================

import express from "express";
import {
  authenticateToken,
  authorizeAdmin,
} from "../middleware/authMiddleware.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { HttpError } from "../utils/HttpError.js";
import { UserService } from "../services/UserService.js";

const router = express.Router();

// Helper for user checks
async function fetchUserOrThrow(id) {
  const user = await UserService.getById(id);
  if (!user) {
    throw new HttpError("User not found.", 404);
  }
  return user;
}

// GET /admin/users
router.get(
  "/users",
  authenticateToken,
  authorizeAdmin,
  asyncHandler(async (req, res) => {
    const users = await UserService.listAll();
    return res.json(users);
  }),
);

// PUT /admin/users/:id/role
router.put(
  "/users/:id/role",
  authenticateToken,
  authorizeAdmin,
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;

    await fetchUserOrThrow(id);
    const updated = await UserService.updateRole(id, role);
    // updated is never null if fetchUserOrThrow passed, but we stay consistent
    if (!updated) {
      throw new HttpError("User not found.", 404);
    }
    return res.json(updated);
  }),
);

// DELETE /admin/users/:id
router.delete(
  "/users/:id",
  authenticateToken,
  authorizeAdmin,
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    await fetchUserOrThrow(id);

    const deleted = await UserService.deleteUser(id);
    if (!deleted) {
      throw new HttpError("User not found.", 404);
    }
    return res.json({ message: "User deleted" });
  }),
);

export default router;


===== ./server/services/UserService.js =====

// =========================
// FILE: server/services/UserService.js
// =========================

import pool from "../database.js";
import bcrypt from "bcryptjs";
import { HttpError } from "../utils/HttpError.js";

export class UserService {
  static async getByEmail(email) {
    const result = await pool.query("SELECT * FROM users WHERE email = $1", [
      email,
    ]);
    if (result.rows.length === 0) return null;
    return result.rows[0];
  }

  static async emailExists(email) {
    const existing = await this.getByEmail(email);
    return !!existing;
  }

  static async createUser(name, email, plainPassword) {
    const existing = await this.getByEmail(email);
    if (existing) {
      throw new HttpError("Email is already in use.", 400);
    }
    const hashedPassword = await bcrypt.hash(plainPassword, 10);
    const result = await pool.query(
      "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id, name, email, role",
      [name, email, hashedPassword],
    );
    return result.rows[0];
  }

  static async comparePasswords(plainText, hashed) {
    return bcrypt.compare(plainText, hashed);
  }

  static async listAll() {
    const result = await pool.query("SELECT id, email, role FROM users");
    return result.rows;
  }

  static async updateRole(userId, newRole) {
    const result = await pool.query(
      "UPDATE users SET role = $1 WHERE id = $2 RETURNING id, email, role",
      [newRole, userId],
    );
    if (result.rows.length === 0) return null;
    return result.rows[0];
  }

  static async deleteUser(userId) {
    const result = await pool.query(
      "DELETE FROM users WHERE id = $1 RETURNING *",
      [userId],
    );
    if (result.rows.length === 0) return null;
    return result.rows[0];
  }

  /**
   * New method => used by fetchUserOrThrow in adminRoutes.js
   */
  static async getById(userId) {
    const result = await pool.query(
      "SELECT id, name, email, role FROM users WHERE id = $1",
      [userId],
    );
    if (result.rows.length === 0) {
      return null;
    }
    return result.rows[0];
  }
}


===== ./server/services/Session.js =====

// =========================
// FILE: server/services/Session.js
// =========================

import { isAdmin } from "../utils/Permissions.js";

export class Session {
  constructor(code) {
    this.code = code;
    this.projectName = "New Project";

    this.users = new Map();
    this.elements = [
      { id: 1, x: 100, y: 100, w: 50, h: 50, lockedBy: null },
      { id: 2, x: 300, y: 200, w: 60, h: 80, lockedBy: null },
    ];

    this.nextJoinOrder = 1;

    // Shared session-wide stacks for undo/redo
    this.undoStack = [];
    this.redoStack = [];

    // If a user starts moving or resizing but hasn't "finalized" it,
    // we store partial changes in these maps:
    //   pendingMoves:   Map<elementId, { userId, oldX, oldY }>
    //   pendingResizes: Map< userId, Map< elementId, { x, y, w, h } > >
    this.pendingMoves = new Map();
    this.pendingResizes = new Map();
  }

  canManage(userId) {
    const user = this.users.get(userId);
    if (!user) return false;
    return isAdmin(user) || user.sessionRole === "owner";
  }

  /**
   * Add or re-join a user to this session:
   * - If brand-new => sessionRole='owner' if no owner exists; else 'viewer'.
   * - If user exists => update name/socket/admin if needed.
   */
  addUser(userId, userName, isAdminFlag = false, wsSocket = null) {
    let userObj = this.users.get(userId);

    if (!userObj) {
      // brand new
      userObj = {
        userId,
        name: userName || "Anonymous",
        color: this._colorFromUserId(userId),
        globalRole: isAdminFlag ? "admin" : "user",
        sessionRole: "viewer",
        socket: wsSocket,
        x: 0,
        y: 0,
        joinOrder: this.nextJoinOrder++,
      };
      this.users.set(userId, userObj);
    } else {
      // re-joining => update name, socket, possibly admin
      userObj.socket = wsSocket;
      if (userName) {
        userObj.name = userName;
      }
      if (isAdminFlag) {
        userObj.globalRole = "admin";
      }
    }

    // If there's truly no owner, make this user the owner
    if (!this._hasOwner()) {
      userObj.sessionRole = "owner";
    }

    return userObj;
  }

  removeUser(userId) {
    const user = this.users.get(userId);
    if (!user) return null;

    // free any locked elements
    for (const el of this.elements) {
      if (el.lockedBy === userId) {
        el.lockedBy = null;
      }
    }

    const wasOwner = user.sessionRole === "owner";
    this.users.delete(userId);

    if (wasOwner) {
      this._reassignOwnerIfNeeded();
    }
    return user;
  }

  kickUser(kickerUserId, targetUserId) {
    const kicker = this.users.get(kickerUserId);
    const target = this.users.get(targetUserId);
    if (!kicker || !target) return null;

    if (!this.canManage(kickerUserId)) return null;
    if (target.sessionRole === "owner" || target.globalRole === "admin") {
      return null;
    }

    // free any locked elements
    for (const el of this.elements) {
      if (el.lockedBy === targetUserId) {
        el.lockedBy = null;
      }
    }
    this.users.delete(targetUserId);

    if (target.sessionRole === "owner") {
      this._reassignOwnerIfNeeded();
    }
    return target;
  }

  /**
   * Upgrades an ephemeral user ID to a "real" user ID, preserving:
   *   - locked elements,
   *   - session roles (owner/editor/viewer),
   *   - pending moves/resizes,
   *   - and merges admin if requested.
   */
  upgradeUserId(oldUserId, newUserId, newName, newIsAdmin, wsSocket) {
    let oldUser = this.users.get(oldUserId);
    if (!oldUser) {
      // create a placeholder so we can "upgrade" it
      oldUser = {
        userId: oldUserId,
        name: "Anonymous",
        color: this._colorFromUserId(oldUserId),
        globalRole: "user",
        sessionRole: "viewer",
        socket: null,
        joinOrder: this.nextJoinOrder++,
      };
      this.users.set(oldUserId, oldUser);
    }

    // 1) Transfer locked elements
    for (const el of this.elements) {
      if (el.lockedBy === oldUserId) {
        el.lockedBy = newUserId;
      }
    }

    // 2) Remove oldUser from the map
    const oldSessionRole = oldUser.sessionRole;
    this.users.delete(oldUserId);

    // 3) Also remove any existing user at newUserId (just in case)
    this.users.delete(newUserId);

    // 4) Overwrite fields in oldUser => store as newUserId
    oldUser.userId = newUserId;
    oldUser.name = newName || oldUser.name;
    oldUser.globalRole = newIsAdmin ? "admin" : "user";
    oldUser.sessionRole = oldSessionRole;
    if (wsSocket) {
      oldUser.socket = wsSocket;
    }
    this.users.set(newUserId, oldUser);

    // 5) Transfer any pending moves referencing oldUserId
    for (const [elementId, moveData] of this.pendingMoves.entries()) {
      if (moveData.userId === oldUserId) {
        moveData.userId = newUserId;
      }
    }

    // 6) Transfer any pending resizes from oldUserId => newUserId
    const oldMap = this.pendingResizes.get(oldUserId);
    if (oldMap) {
      this.pendingResizes.delete(oldUserId);
      // If there's already a map for newUserId, merge them
      const existingMap = this.pendingResizes.get(newUserId) || new Map();
      // Copy all from oldMap into existingMap
      for (const [elId, originalPos] of oldMap.entries()) {
        existingMap.set(elId, originalPos);
      }
      this.pendingResizes.set(newUserId, existingMap);
    }

    return oldUser;
  }

  /**
   * Downgrades a user => merges locks, sets them to viewer, clears admin,
   * reassigns ownership if needed.
   */
  downgradeUserId(oldUserId, newUserId, wsSocket) {
    let oldUser = this.users.get(oldUserId);
    if (!oldUser) {
      // create a placeholder so we can "downgrade" it
      oldUser = {
        userId: oldUserId,
        name: "Anonymous",
        color: this._colorFromUserId(oldUserId),
        globalRole: "user",
        sessionRole: "viewer",
        socket: null,
        joinOrder: this.nextJoinOrder++,
      };
      this.users.set(oldUserId, oldUser);
    }

    const wasOwner = oldUser.sessionRole === "owner";

    // free or reassign locks
    for (const el of this.elements) {
      if (el.lockedBy === oldUserId) {
        el.lockedBy = newUserId;
      }
    }

    this.users.delete(oldUserId);

    oldUser.userId = newUserId;
    oldUser.name = "Anonymous";
    oldUser.globalRole = "user";
    oldUser.sessionRole = "viewer";
    oldUser.joinOrder = this.nextJoinOrder++;

    if (wsSocket) {
      oldUser.socket = wsSocket;
    }
    this.users.set(newUserId, oldUser);

    // Also fix pending moves
    for (const [elementId, moveData] of this.pendingMoves.entries()) {
      if (moveData.userId === oldUserId) {
        moveData.userId = newUserId;
      }
    }

    // Fix pending resizes
    const oldMap = this.pendingResizes.get(oldUserId);
    if (oldMap) {
      this.pendingResizes.delete(oldUserId);
      const existingMap = this.pendingResizes.get(newUserId) || new Map();
      for (const [elId, originalPos] of oldMap.entries()) {
        existingMap.set(elId, originalPos);
      }
      this.pendingResizes.set(newUserId, existingMap);
    }

    if (wasOwner) {
      this._reassignOwnerIfNeeded(newUserId);
    }

    return oldUser;
  }

  setEditorRole(targetUserId, isEditor) {
    const user = this.users.get(targetUserId);
    if (!user) return false;
    user.sessionRole = isEditor ? "editor" : "viewer";
    return true;
  }

  clearUndoRedo() {
    this.undoStack = [];
    this.redoStack = [];
  }

  _reassignOwnerIfNeeded(excludeUserId = null) {
    if (this._hasOwner()) return;

    let candidates = [...this.users.values()];
    if (excludeUserId) {
      candidates = candidates.filter((u) => u.userId !== excludeUserId);
    }
    if (candidates.length === 0) return;

    candidates.sort((a, b) => a.joinOrder - b.joinOrder);
    candidates[0].sessionRole = "owner";
  }

  _hasOwner() {
    return [...this.users.values()].some((u) => u.sessionRole === "owner");
  }

  _colorFromUserId(userId) {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }
    const r = (hash >> 16) & 0xff;
    const g = (hash >> 8) & 0xff;
    const b = hash & 0xff;
    return `rgb(${r},${g},${b})`;
  }
}


===== ./server/services/SessionService.js =====

// server/services/SessionService.js
import { Session } from "./Session.js";

const sessionMap = new Map();

export class SessionService {
  static getSession(code) {
    return sessionMap.get(code) || null;
  }

  static getOrCreateSession(code) {
    let session = this.getSession(code);
    if (!session) {
      session = new Session(code);
      sessionMap.set(code, session);
    }
    return session;
  }

  static removeSession(code) {
    sessionMap.delete(code);
  }
}


===== ./server/services/AuthService.js =====

// server/services/AuthService.js

import jwt from "jsonwebtoken";
import config from "../config.js";

/**
 * Centralizes all logic for creating and verifying JWTs,
 * plus transforms from user row -> token payload.
 */
export class AuthService {
  /**
   * Returns the payload object you want to store in the token.
   * We now include `role` and set `isAdmin` = true if role === 'admin'.
   */
  static userPayload(user) {
    return {
      id: user.id,
      email: user.email,
      role: user.role,
      name: user.name,
      isAdmin: user.role === "admin",
    };
  }

  /**
   * Create a JWT string from a given payload object.
   */
  static createToken(payload, expiresIn = "1h") {
    return jwt.sign(payload, config.JWT_SECRET, { expiresIn });
  }

  /**
   * Verify a JWT string. If invalid, this throws an error.
   * On success, returns the decoded payload (including `isAdmin`).
   */
  static verifyToken(token) {
    return jwt.verify(token, config.JWT_SECRET);
  }
}


===== ./server/services/ProjectService.js =====

// server/services/ProjectService.js
import pool from "../database.js";
import { HttpError } from "../utils/HttpError.js";

export class ProjectService {
  static async getProjectsByOwner(userId) {
    const result = await pool.query(
      "SELECT * FROM projects WHERE owner_id = $1",
      [userId],
    );
    return result.rows;
  }

  static async createProject(ownerId, name, description) {
    const result = await pool.query(
      "INSERT INTO projects (name, description, owner_id) VALUES ($1, $2, $3) RETURNING *",
      [name, description, ownerId],
    );
    return result.rows[0];
  }

  static async updateProject(projectId, name, description) {
    const result = await pool.query(
      "UPDATE projects SET name = $1, description = $2 WHERE id = $3 RETURNING *",
      [name, description, projectId],
    );
    return result.rows[0] || null;
  }

  static async deleteProject(projectId) {
    await pool.query("DELETE FROM project_versions WHERE project_id = $1", [
      projectId,
    ]);
    const result = await pool.query(
      "DELETE FROM projects WHERE id = $1 RETURNING *",
      [projectId],
    );
    return result.rows[0] || null;
  }

  static async createDefaultProjectIfNone(userId) {
    const existing = await pool.query(
      "SELECT * FROM projects WHERE owner_id = $1 ORDER BY id LIMIT 1",
      [userId],
    );
    if (existing.rows.length > 0) {
      return existing.rows[0];
    }
    const result = await pool.query(
      "INSERT INTO projects (name, description, owner_id) VALUES ($1, $2, $3) RETURNING *",
      ["My Default Project", "Auto-created for user", userId],
    );
    return result.rows[0];
  }

  static async listVersions(projectId) {
    const result = await pool.query(
      `SELECT id, version_number, created_at
       FROM project_versions
       WHERE project_id = $1
       ORDER BY version_number DESC`,
      [projectId],
    );
    return result.rows;
  }

  static async createVersion(projectId, projectData) {
    const maxVer = await this._getMaxVersionNumber(projectId);
    const newVer = maxVer + 1;

    const insertResult = await pool.query(
      `INSERT INTO project_versions (project_id, version_number, project_data)
       VALUES ($1, $2, $3)
       RETURNING id, version_number, created_at`,
      [projectId, newVer, projectData || {}],
    );
    return insertResult.rows[0];
  }

  static async rollbackVersion(projectId, versionId) {
    const oldVersionResult = await pool.query(
      `SELECT id, version_number, project_data
       FROM project_versions
       WHERE project_id = $1
         AND id = $2`,
      [projectId, versionId],
    );
    if (oldVersionResult.rows.length === 0) {
      throw new HttpError("Version not found.", 404);
    }
    const oldData = oldVersionResult.rows[0].project_data;

    const maxVer = await this._getMaxVersionNumber(projectId);
    const newVer = maxVer + 1;

    const rollbackInsert = await pool.query(
      `INSERT INTO project_versions (project_id, version_number, project_data)
       VALUES ($1, $2, $3)
       RETURNING id, version_number, created_at`,
      [projectId, newVer, oldData],
    );

    return {
      message: "Project rolled back successfully",
      newVersion: rollbackInsert.rows[0],
    };
  }

  /**
   * The test for an admin user sends { role: 'admin' }.
   * So we check user.role==='admin' to skip DB calls.
   */
  static async userCanEditProject(projectId, user) {
    if (!user) return false;
    // short-circuit if user has role 'admin'
    if (user.role === "admin") return true;

    const ownerId = await this.getProjectOwnerId(projectId);
    if (!ownerId) return false;
    return ownerId === user.id;
  }

  static async getProjectOwnerId(projectId) {
    const result = await pool.query(
      "SELECT owner_id FROM projects WHERE id = $1",
      [projectId],
    );
    if (result.rows.length === 0) {
      return null;
    }
    return result.rows[0].owner_id;
  }

  // Internal helper for version numbering
  static async _getMaxVersionNumber(projectId) {
    const result = await pool.query(
      `SELECT COALESCE(MAX(version_number), 0) AS max_ver
       FROM project_versions
       WHERE project_id = $1`,
      [projectId],
    );
    return result.rows[0].max_ver || 0;
  }
}


===== ./server/ws/messageDispatcher.js =====

// ./server/ws/messageDispatcher.js
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";
import * as sessionHandlers from "./handlers/sessionHandlers.js";
import * as cursorHandlers from "./handlers/cursorHandlers.js";
import * as elementHandlers from "./handlers/elementHandlers.js";
import * as permissionHandlers from "./handlers/permissionHandlers.js";
import * as projectHandlers from "./handlers/projectHandlers.js";
import * as undoRedoHandlers from "./handlers/undoRedoHandlers.js";
import * as chatHandlers from "./handlers/chatHandlers.js";

const handlerMap = {
  [MESSAGE_TYPES.JOIN_SESSION]: sessionHandlers.handleJoinSession,
  [MESSAGE_TYPES.UPGRADE_USER_ID]: sessionHandlers.handleUpgradeUserId,
  [MESSAGE_TYPES.DOWNGRADE_USER_ID]: sessionHandlers.handleDowngradeUserId,
  [MESSAGE_TYPES.CURSOR_UPDATE]: cursorHandlers.handleCursorUpdate,

  [MESSAGE_TYPES.ELEMENT_GRAB]: elementHandlers.handleElementGrab,
  [MESSAGE_TYPES.ELEMENT_MOVE]: elementHandlers.handleElementMove,
  [MESSAGE_TYPES.ELEMENT_RELEASE]: elementHandlers.handleElementRelease,
  [MESSAGE_TYPES.ELEMENT_DESELECT]: elementHandlers.handleElementDeselect,
  [MESSAGE_TYPES.ELEMENT_CREATE]: elementHandlers.handleElementCreate,
  [MESSAGE_TYPES.ELEMENT_DELETE]: elementHandlers.handleElementDelete,
  [MESSAGE_TYPES.ELEMENT_RESIZE]: elementHandlers.handleElementResize,
  [MESSAGE_TYPES.ELEMENT_RESIZE_END]: elementHandlers.handleElementResizeEnd,
  [MESSAGE_TYPES.ELEMENT_ROTATE]: elementHandlers.handleElementRotate,
  [MESSAGE_TYPES.ELEMENT_ROTATE_END]: elementHandlers.handleElementRotateEnd,
  [MESSAGE_TYPES.MAKE_EDITOR]: permissionHandlers.handleMakeEditor,
  [MESSAGE_TYPES.REMOVE_EDITOR]: permissionHandlers.handleRemoveEditor,
  [MESSAGE_TYPES.KICK_USER]: permissionHandlers.handleKickUser,
  [MESSAGE_TYPES.PROJECT_NAME_CHANGE]: projectHandlers.handleProjectNameChange,
  [MESSAGE_TYPES.UNDO]: undoRedoHandlers.handleUndo,
  [MESSAGE_TYPES.REDO]: undoRedoHandlers.handleRedo,
  [MESSAGE_TYPES.CHAT_MESSAGE]: chatHandlers.handleChatMessage,
};

export function handleIncomingMessage(session, data, ws) {
  const handler = handlerMap[data.type];
  if (handler) {
    handler(session, data, ws);
  }
}


===== ./server/ws/collabUtils.js =====

/**
 * ./server/ws/collabUtils.js
 */
import { WebSocket } from "ws";
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

/**
 * Broadcast a data object (JSON) to all connected user sockets in a session.
 */
export function broadcastToSession(session, data) {
  const msg = JSON.stringify(data);
  for (const user of session.users.values()) {
    if (user.socket && user.socket.readyState === WebSocket.OPEN) {
      user.socket.send(msg);
    }
  }
}

/**
 * Broadcast the current element state (elements array + projectName) to all in the session.
 * (Logging removed for cleanliness. If you want logs, you can add them here.)
 */
export function broadcastElementState(session) {
  broadcastToSession(session, {
    type: MESSAGE_TYPES.ELEMENT_STATE,
    elements: session.elements,
    projectName: session.projectName,
  });
}

/**
 * Broadcast the current user list, sorted by joinOrder.
 */
export function broadcastUserList(session) {
  const sorted = [...session.users.values()].sort(
    (a, b) => a.joinOrder - b.joinOrder,
  );

  const userList = sorted.map((u) => ({
    userId: u.userId,
    name: u.name,
    color: u.color,
    sessionRole: u.sessionRole,
    globalRole: u.globalRole,
  }));

  broadcastToSession(session, {
    type: MESSAGE_TYPES.SESSION_USERS,
    users: userList,
  });
}


===== ./server/ws/collaboration.js =====

// server/ws/collaboration.js
import { WebSocket } from "ws";
import { handleIncomingMessage } from "./messageDispatcher.js";
import { SessionService } from "../services/SessionService.js";
import { broadcastUserList, broadcastElementState } from "./collabUtils.js";

/**
 * Each new WebSocket connection => store references, handle messages, handle close.
 */
export function handleWebSocketConnection(ws, wss) {
  ws.on("message", (raw) => {
    let data;
    try {
      data = JSON.parse(raw);
    } catch {
      // ignore parse errors
      return;
    }

    // fetch session if known
    const session = ws.sessionCode
      ? SessionService.getSession(ws.sessionCode)
      : null;
    handleIncomingMessage(session, data, ws);
  });

  ws.on("close", () => {
    const code = ws.sessionCode;
    const userId = ws.userId;
    if (!code || !userId) return;

    const session = SessionService.getSession(code);
    if (!session) return;

    // Remove user => frees locks, etc.
    session.removeUser(userId);

    // Now broadcast updated user list & element state so
    // other clients see the freed locks & updated session users
    broadcastUserList(session);
    broadcastElementState(session);

    // If no users remain, remove the session from memory
    if (session.users.size === 0) {
      SessionService.removeSession(code);
    }
  });
}


===== ./server/ws/handlers/elementHandlers.js =====

// ./server/ws/handlers/elementHandlers.js
import { broadcastElementState } from "../collabUtils.js";
import { pushUndoAction } from "./undoRedoHandlers.js";
import { sessionGuard } from "./handlerUtils.js";

function isElementLockedByOthers(element, userId) {
  return element.lockedBy && element.lockedBy !== userId;
}

// Finalize all pending moves for user ...
function finalizeAllPendingMovesForUser(session, userId) {
  if (!session.pendingMoves) return;
  const diffs = [];

  for (const [elId, moveData] of session.pendingMoves.entries()) {
    if (moveData.userId !== userId) continue;

    const el = session.elements.find((e) => e.id === elId);
    session.pendingMoves.delete(elId);

    if (!el) continue;
    const changed = el.x !== moveData.oldX || el.y !== moveData.oldY;
    if (changed) {
      diffs.push({
        elementId: elId,
        from: { x: moveData.oldX, y: moveData.oldY },
        to: { x: el.x, y: el.y },
      });
    }
  }
  if (diffs.length > 0) {
    const action = { type: "move", diffs };
    pushUndoAction(session, action);
  }
}

// Finalize all pending resizes ...
function finalizeAllPendingResizesForUser(session, userId) {
  if (!session.pendingResizes) return;
  const userMap = session.pendingResizes.get(userId);
  if (!userMap) return;

  const diffs = [];
  for (const [elId, original] of userMap.entries()) {
    const el = session.elements.find((e) => e.id === elId);
    if (!el) continue;

    const changed =
      el.x !== original.x ||
      el.y !== original.y ||
      el.w !== original.w ||
      el.h !== original.h;
    if (changed) {
      diffs.push({
        elementId: elId,
        from: { ...original },
        to: { x: el.x, y: el.y, w: el.w, h: el.h },
      });
    }
  }
  userMap.clear();
  session.pendingResizes.delete(userId);

  if (diffs.length > 0) {
    const action = { type: "resize", diffs };
    pushUndoAction(session, action);
  }
}

/**
 * NEW: finalizeAllPendingRotationsForUser
 * Similar approach: gather "from->to" angle diffs and push to undo stack.
 */
function finalizeAllPendingRotationsForUser(session, userId) {
  if (!session.pendingRotations) return;
  const userMap = session.pendingRotations.get(userId);
  if (!userMap) return;

  const diffs = [];
  for (const [elId, originalAngle] of userMap.entries()) {
    const el = session.elements.find((e) => e.id === elId);
    if (!el) continue;

    if (el.angle !== originalAngle) {
      diffs.push({
        elementId: elId,
        fromAngle: originalAngle,
        toAngle: el.angle,
      });
    }
  }
  userMap.clear();
  session.pendingRotations.delete(userId);

  if (diffs.length > 0) {
    const action = { type: "rotate", diffs };
    pushUndoAction(session, action);
  }
}

export const handleElementGrab = sessionGuard((session, data, ws) => {
  const { userId, elementId } = data;
  finalizeAllPendingResizesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  const el = session.elements.find((e) => e.id === elementId);
  if (!el) return;

  if (isElementLockedByOthers(el, userId)) return;
  el.lockedBy = userId;
  broadcastElementState(session);
});

export const handleElementMove = sessionGuard((session, data, ws) => {
  const { userId, elementId, x, y } = data;

  finalizeAllPendingResizesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  const el = session.elements.find((e) => e.id === elementId);
  if (!el) return;

  if (el.lockedBy === userId) {
    if (!session.pendingMoves) {
      session.pendingMoves = new Map();
    }
    if (!session.pendingMoves.has(elementId)) {
      session.pendingMoves.set(elementId, {
        userId,
        oldX: el.x,
        oldY: el.y,
      });
    }
    el.x = x;
    el.y = y;
    broadcastElementState(session);
  }
});

export const handleElementRelease = sessionGuard((session, data, ws) => {
  const { userId } = data;

  // finalize moves only
  finalizeAllPendingMovesForUser(session, userId);
  // we do NOT unlock the element here by design
  broadcastElementState(session);
});

export const handleElementDeselect = sessionGuard((session, data, ws) => {
  const { userId, elementIds } = data;
  if (!Array.isArray(elementIds)) return;

  finalizeAllPendingMovesForUser(session, userId);
  finalizeAllPendingResizesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  for (const elementId of elementIds) {
    const el = session.elements.find((e) => e.id === elementId);
    if (el && el.lockedBy === userId) {
      el.lockedBy = null;
    }
  }
  broadcastElementState(session);
});

export const handleElementCreate = sessionGuard((session, data, ws) => {
  const { userId, shape, x, y, w, h } = data;
  if (!userId || !shape) return;

  finalizeAllPendingMovesForUser(session, userId);
  finalizeAllPendingResizesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  let maxId = 0;
  for (const e of session.elements) {
    if (e.id > maxId) maxId = e.id;
  }
  const newId = maxId + 1;

  const newElement = {
    id: newId,
    shape,
    x,
    y,
    w,
    h,
    angle: 0, // NEW: default angle
    lockedBy: userId,
  };
  session.elements.push(newElement);

  const action = {
    type: "create",
    diffs: [
      {
        elementId: newId,
        shape,
        x,
        y,
        w,
        h,
      },
    ],
  };
  pushUndoAction(session, action);

  broadcastElementState(session);
});

export const handleElementDelete = sessionGuard((session, data, ws) => {
  const { userId, elementIds } = data;
  if (!Array.isArray(elementIds) || elementIds.length === 0) return;

  finalizeAllPendingMovesForUser(session, userId);
  finalizeAllPendingResizesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  const toDelete = [];
  for (const id of elementIds) {
    const idx = session.elements.findIndex((e) => e.id === id);
    if (idx >= 0) {
      const el = session.elements[idx];
      if (isElementLockedByOthers(el, userId)) {
        continue;
      }
      toDelete.push({ ...el });
      session.elements.splice(idx, 1);
    }
  }
  if (toDelete.length === 0) {
    broadcastElementState(session);
    return;
  }

  const action = {
    type: "delete",
    diffs: toDelete.map((el) => ({
      id: el.id,
      shape: el.shape,
      x: el.x,
      y: el.y,
      w: el.w,
      h: el.h,
      lockedBy: el.lockedBy,
    })),
  };
  pushUndoAction(session, action);

  broadcastElementState(session);
});

export const handleElementResize = sessionGuard((session, data, ws) => {
  const { userId, elementId, x, y, w, h } = data;

  finalizeAllPendingMovesForUser(session, userId);
  finalizeAllPendingRotationsForUser(session, userId);

  const el = session.elements.find((e) => e.id === elementId);
  if (!el) return;

  if (isElementLockedByOthers(el, userId)) return;
  if (!el.lockedBy) {
    el.lockedBy = userId;
  }

  if (!session.pendingResizes) {
    session.pendingResizes = new Map();
  }
  let userMap = session.pendingResizes.get(userId);
  if (!userMap) {
    userMap = new Map();
    session.pendingResizes.set(userId, userMap);
  }
  if (!userMap.has(elementId)) {
    userMap.set(elementId, { x: el.x, y: el.y, w: el.w, h: el.h });
  }

  el.x = x;
  el.y = y;
  el.w = w;
  el.h = h;

  broadcastElementState(session);
});

export const handleElementResizeEnd = sessionGuard((session, data, ws) => {
  const { userId, elementIds } = data;
  if (!Array.isArray(elementIds) || elementIds.length === 0) {
    broadcastElementState(session);
    return;
  }
  finalizeAllPendingResizesForUser(session, userId);
  broadcastElementState(session);
});

/* ------------------------------------------------------------------
   NEW: Rotation Handlers
------------------------------------------------------------------ */
export const handleElementRotate = sessionGuard((session, data, ws) => {
  const { userId, elementId, angle } = data;
  console.log(userId, elementId, angle);
  // finalize moves/resizes so they don't merge
  finalizeAllPendingMovesForUser(session, userId);
  finalizeAllPendingResizesForUser(session, userId);

  const el = session.elements.find((e) => e.id === elementId);
  if (!el) return;
  if (isElementLockedByOthers(el, userId)) return;

  // auto-lock if not locked
  if (!el.lockedBy) {
    el.lockedBy = userId;
  }
  if (el.lockedBy !== userId) return;

  if (!session.pendingRotations) {
    session.pendingRotations = new Map();
  }
  let userMap = session.pendingRotations.get(userId);
  if (!userMap) {
    userMap = new Map();
    session.pendingRotations.set(userId, userMap);
  }
  if (!userMap.has(elementId)) {
    userMap.set(elementId, el.angle); // store original angle
  }

  // update element's angle
  el.angle = angle;
  broadcastElementState(session);
});

export const handleElementRotateEnd = sessionGuard((session, data, ws) => {
  const { userId, elementIds } = data;
  if (!Array.isArray(elementIds) || elementIds.length === 0) {
    broadcastElementState(session);
    return;
  }
  // finalize rotation diffs into an undo action
  finalizeAllPendingRotationsForUser(session, userId);
  broadcastElementState(session);
});


===== ./server/ws/handlers/undoRedoHandlers.js =====

// ./server/ws/handlers/undoRedoHandlers.js
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { broadcastElementState } from "../collabUtils.js";
import { sessionGuard } from "./handlerUtils.js";

export function pushUndoAction(session, action) {
  session.redoStack = [];
  session.undoStack.push(action);
  if (session.undoStack.length > 50) {
    session.undoStack.shift();
  }
}

export const handleUndo = sessionGuard((session, data, ws) => {
  const { userId } = data;

  if (session.undoStack.length === 0) {
    return;
  }
  const action = session.undoStack[session.undoStack.length - 1];
  if (!canApplyAction(session, action, userId)) {
    ws.send(
      JSON.stringify({
        type: MESSAGE_TYPES.UNDO_REDO_FAILED,
        reason: "Element locked by another user or concurrency issue.",
      }),
    );
    return;
  }

  session.undoStack.pop();
  revertAction(session, action);
  session.redoStack.push(action);

  broadcastElementState(session);
});

export const handleRedo = sessionGuard((session, data, ws) => {
  const { userId } = data;

  if (session.redoStack.length === 0) {
    return;
  }
  const action = session.redoStack[session.redoStack.length - 1];
  if (!canApplyAction(session, action, userId)) {
    ws.send(
      JSON.stringify({
        type: MESSAGE_TYPES.UNDO_REDO_FAILED,
        reason: "Element locked by another user or concurrency issue.",
      }),
    );
    return;
  }

  session.redoStack.pop();
  applyAction(session, action);
  session.undoStack.push(action);

  broadcastElementState(session);
});

function canApplyAction(session, action, userId) {
  if (!action?.diffs || !Array.isArray(action.diffs)) return true;
  if (!["move", "create", "delete", "resize", "rotate"].includes(action.type))
    return true;

  for (const diff of action.diffs) {
    let elId;
    if (action.type === "delete") {
      elId = diff.id;
    } else if (action.type === "rotate") {
      elId = diff.elementId;
    } else {
      elId = diff.elementId;
    }

    const el = session.elements.find((e) => e.id === elId);
    if (!el) continue;
    if (el.lockedBy && el.lockedBy !== userId) {
      return false;
    }
  }
  return true;
}

function applyAction(session, action) {
  switch (action.type) {
    case "move":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.x = diff.to.x;
        el.y = diff.to.y;
      }
      break;
    case "create":
      for (const diff of action.diffs) {
        const existing = session.elements.find((e) => e.id === diff.elementId);
        if (!existing) {
          session.elements.push({
            id: diff.elementId,
            shape: diff.shape,
            x: diff.x,
            y: diff.y,
            w: diff.w,
            h: diff.h,
            angle: diff.angle || 0,
            lockedBy: null,
          });
        }
      }
      break;
    case "delete":
      for (const d of action.diffs) {
        const idx = session.elements.findIndex((e) => e.id === d.id);
        if (idx >= 0) {
          session.elements.splice(idx, 1);
        }
      }
      break;
    case "resize":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.x = diff.to.x;
        el.y = diff.to.y;
        el.w = diff.to.w;
        el.h = diff.to.h;
      }
      break;
    case "rotate":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.angle = diff.toAngle;
      }
      break;
    default:
      break;
  }
}

function revertAction(session, action) {
  switch (action.type) {
    case "move":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.x = diff.from.x;
        el.y = diff.from.y;
      }
      break;
    case "create":
      for (const diff of action.diffs) {
        const idx = session.elements.findIndex((e) => e.id === diff.elementId);
        if (idx >= 0) {
          session.elements.splice(idx, 1);
        }
      }
      break;
    case "delete":
      for (const d of action.diffs) {
        const exists = session.elements.find((e) => e.id === d.id);
        if (!exists) {
          session.elements.push({
            id: d.id,
            shape: d.shape,
            x: d.x,
            y: d.y,
            w: d.w,
            h: d.h,
            angle: d.angle || 0,
            lockedBy: null,
          });
        }
      }
      break;
    case "resize":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.x = diff.from.x;
        el.y = diff.from.y;
        el.w = diff.from.w;
        el.h = diff.from.h;
      }
      break;
    case "rotate":
      for (const diff of action.diffs) {
        const el = session.elements.find((e) => e.id === diff.elementId);
        if (!el) continue;
        el.angle = diff.fromAngle;
      }
      break;
    default:
      break;
  }
}


===== ./server/ws/handlers/projectHandlers.js =====

// ./server/ws/handlers/projectHandlers.js
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { broadcastToSession, broadcastElementState } from "../collabUtils.js";
import { sessionGuard } from "./handlerUtils.js";
import { canRenameProject } from "../../utils/Permissions.js";

export const handleProjectNameChange = sessionGuard((session, data, ws) => {
  const { userId, newName } = data;
  if (!newName || !userId) return;

  const user = session.users.get(userId);
  if (!user) return;

  if (canRenameProject(user)) {
    session.projectName = newName;

    broadcastToSession(session, {
      type: MESSAGE_TYPES.PROJECT_NAME_CHANGE,
      newName,
    });
    broadcastElementState(session);
  }
});


===== ./server/ws/handlers/chatHandlers.js =====

// ./server/ws/handlers/chatHandlers.js

import { broadcastToSession } from "../collabUtils.js";
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { sessionGuard } from "./handlerUtils.js";

export const handleChatMessage = sessionGuard((session, data, ws) => {
  const { userId, text } = data;
  if (!text || !userId) return;

  if (!session.chatMessages) {
    session.chatMessages = [];
  }

  const msgObj = {
    userId,
    text,
    timestamp: Date.now(),
  };

  session.chatMessages.push(msgObj);

  broadcastToSession(session, {
    type: MESSAGE_TYPES.CHAT_MESSAGE,
    message: msgObj,
  });
});


===== ./server/ws/handlers/permissionHandlers.js =====

// server/ws/handlers/permissionHandlers.js

import { broadcastUserList, broadcastElementState } from "../collabUtils.js";
import { WebSocket } from "ws";
import { sessionGuard } from "./handlerUtils.js";
import { canManageOthers, canKickUser } from "../../utils/Permissions.js";

export const handleMakeEditor = sessionGuard((session, data, ws) => {
  const { userId, targetUserId } = data;
  const manager = session.users.get(userId);
  const target = session.users.get(targetUserId);
  if (!manager || !target) return;

  if (!canManageOthers(manager)) {
    return;
  }

  // set sessionRole='editor' if target isn't already 'owner' or 'admin'
  // (though admin is global, we could allow an admin to also be an 'editor',
  // but that may be redundant).
  if (target.sessionRole !== "owner") {
    session.setEditorRole(targetUserId, true);
    broadcastUserList(session);
  }
});

export const handleRemoveEditor = sessionGuard((session, data, ws) => {
  const { userId, targetUserId } = data;
  const manager = session.users.get(userId);
  const target = session.users.get(targetUserId);
  if (!manager || !target) return;

  if (!canManageOthers(manager)) {
    return;
  }

  if (target.sessionRole === "editor") {
    session.setEditorRole(targetUserId, false);
    broadcastUserList(session);
  }
});

export const handleKickUser = sessionGuard((session, data, ws) => {
  const { userId, targetUserId } = data;
  const kicker = session.users.get(userId);
  const target = session.users.get(targetUserId);
  if (!kicker || !target) return;

  if (!canKickUser(kicker, target)) {
    return;
  }

  const kickedUser = session.kickUser(userId, targetUserId);
  if (!kickedUser) {
    return;
  }

  broadcastUserList(session);
  broadcastElementState(session);

  if (kickedUser.socket && kickedUser.socket.readyState === WebSocket.OPEN) {
    kickedUser.socket.send(JSON.stringify({ type: "kicked" }), () => {
      setTimeout(() => kickedUser.socket.close(), 50);
    });
  } else {
    kickedUser.socket?.close();
  }
});


===== ./server/ws/handlers/cursorHandlers.js =====

// ./server/ws/handlers/cursorHandlers.js

import { broadcastToSession } from "../collabUtils.js";
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { sessionGuard } from "./handlerUtils.js";

export const handleCursorUpdate = sessionGuard((session, data, ws) => {
  const { userId, x, y } = data;

  const user = session.users.get(userId);
  if (!user) return;

  user.x = x;
  user.y = y;

  broadcastToSession(session, {
    type: MESSAGE_TYPES.CURSOR_UPDATE,
    userId,
    x,
    y,
  });
});


===== ./server/ws/handlers/sessionHandlers.js =====

// =========================
// FILE: server/ws/handlers/sessionHandlers.js
// =========================

import { SessionService } from "../../services/SessionService.js";
import { broadcastUserList, broadcastElementState } from "../collabUtils.js";
import { sessionGuard } from "./handlerUtils.js";

/**
 * handleJoinSession remains unguarded because it can create or retrieve a session
 * if none is provided.
 */
export function handleJoinSession(session, data, ws) {
  const { userId, name, sessionCode, userRole } = data;
  if (!userId) return;

  // If session is not explicitly passed, we fetch or create:
  const theSession =
    session ||
    SessionService.getOrCreateSession(sessionCode || "defaultSession");

  // Instead of always "false" for non-admin, we pass `undefined` if userRole != 'admin'.
  const isAdmin = userRole === "admin" ? true : undefined;

  const userObj = theSession.addUser(userId, name, isAdmin, ws);

  ws.sessionCode = theSession.code;
  ws.userId = userObj.userId;

  broadcastUserList(theSession);
  broadcastElementState(theSession);
}

export const handleUpgradeUserId = sessionGuard((session, data, ws) => {
  const { oldUserId, newUserId, newName, newIsAdmin } = data;
  // Merge old ephemeral user → newly logged-in user
  const userObj = session.upgradeUserId(
    oldUserId,
    newUserId,
    newName,
    newIsAdmin,
    ws,
  );
  if (!userObj) return;

  // Update the ws fields to reflect the new ID
  ws.userId = userObj.userId;

  // *** CRITICAL FIX: Always broadcast after upgrade ***
  broadcastUserList(session);
  broadcastElementState(session);
});

export const handleDowngradeUserId = sessionGuard((session, data, ws) => {
  const { oldUserId, newUserId } = data;

  const userObj = session.downgradeUserId(oldUserId, newUserId, ws);
  if (!userObj) return;

  ws.userId = userObj.userId;
  broadcastUserList(session);
  broadcastElementState(session);
});


===== ./server/ws/handlers/handlerUtils.js =====

// server/ws/handlers/handlerUtils.js

/**
 * sessionGuard(fn) => returns a handler that only runs if `session` is truthy.
 * This avoids repeating `if (!session) return;` in each handler.
 */
export function sessionGuard(fn) {
  return function (session, data, ws) {
    if (!session) return;
    return fn(session, data, ws);
  };
}


===== ./shared/wsMessageTypes.js =====

// ./shared/wsMessageTypes.js

export const MESSAGE_TYPES = {
  JOIN_SESSION: "join-session",
  CURSOR_UPDATE: "cursor-update",
  CURSOR_UPDATES: "cursor-updates",

  ELEMENT_GRAB: "element-grab",
  ELEMENT_MOVE: "element-move",
  ELEMENT_RELEASE: "element-release",
  ELEMENT_STATE: "element-state",

  ELEMENT_DESELECT: "element-deselect",
  ELEMENT_CREATE: "element-create",
  ELEMENT_DELETE: "element-delete",

  ELEMENT_RESIZE: "element-resize",
  ELEMENT_RESIZE_END: "element-resize-end",

  ELEMENT_ROTATE: "element-rotate",
  ELEMENT_ROTATE_END: "element-rotate-end",

  PROJECT_NAME_CHANGE: "project-name-change",
  SESSION_USERS: "session-users",
  UPGRADE_USER_ID: "upgrade-user-id",

  MAKE_EDITOR: "make-editor",
  REMOVE_EDITOR: "remove-editor",
  KICK_USER: "kick-user",
  KICKED: "kicked",

  UNDO: "undo",
  REDO: "redo",
  UNDO_REDO_FAILED: "undo-redo-failed",

  CHAT_MESSAGE: "chat-message",
};


===== ./client/index.html =====

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Board Game Prototyping</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <div id="app">
      <!-- TOP-LEFT: Project Info -->
      <div id="project-info" class="floating-panel">
        <span id="project-name" title="Click to edit project name">Test</span>
        <button id="open-project-manager" title="Manage Project">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="currentColor"
            viewBox="0 0 16 16"
          >
            <path d="M3 3h10v10H3V3zm9 9V4H4v8h8z" />
            <path d="M8 8.5l-4 2V6l4 2.5l4-2.5v4.5l-4-2z" />
          </svg>
        </button>
      </div>

      <!-- TOP-RIGHT: Local user info -->
      <div id="user-info" class="floating-panel">
        <span id="user-name">Anonymous</span>
        <div id="user-circle">
          <span id="user-circle-text">?</span>
        </div>

        <!-- Login popover if not logged in -->
        <div id="login-dropdown" class="floating-panel hidden">
          <form id="loginForm">
            <div class="login-row">
              <input
                type="email"
                id="loginEmail"
                placeholder="Email"
                required
              />
            </div>
            <div class="login-row">
              <input
                type="password"
                id="loginPassword"
                placeholder="Password"
                required
              />
            </div>
            <div class="login-actions">
              <a href="#" id="registerLink">Register</a>
              <button type="submit">Login</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Session users list (floated left) -->
      <ul id="session-users-list" class="floating-panel"></ul>

      <!--
      TOOLS PALETTE (VERTICAL, LEFT SIDE).
      Defaulting to "select" tool.
    -->
      <div id="tools-palette" class="floating-panel left-tools-palette">
        <button
          data-tool="select"
          class="tool-btn selected"
          title="Select Tool"
        >
          Select
        </button>
        <button data-tool="rectangle" class="tool-btn" title="Draw Rectangle">
          Rectangle
        </button>
        <button data-tool="ellipse" class="tool-btn" title="Draw Ellipse">
          Ellipse
        </button>
        <button data-tool="text" class="tool-btn" title="Place Text Label">
          Text
        </button>
      </div>

      <!-- REGISTER MODAL -->
      <div id="register-modal" class="modal-backdrop hidden">
        <div class="modal-content floating-panel">
          <h2>Register Account</h2>
          <div id="register-message" class="message"></div>
          <form id="registerForm">
            <label for="regName">Name</label>
            <input type="text" id="regName" required />

            <label for="regEmail">Email</label>
            <input type="email" id="regEmail" required />

            <label for="regPassword">Password</label>
            <input type="password" id="regPassword" required />

            <label for="regConfirm">Confirm Password</label>
            <input type="password" id="regConfirm" required />

            <div style="margin-top: 1em">
              <button type="submit">Register</button>
              <button type="button" id="registerCancelBtn">Cancel</button>
            </div>
          </form>
        </div>
      </div>

      <!-- PROJECT MANAGEMENT MODAL -->
      <div id="project-manager-modal" class="modal-backdrop hidden">
        <div class="modal-content floating-panel">
          <h2>Project Management</h2>

          <div id="messageContainer"></div>

          <div class="versions-section">
            <h3>Versions</h3>
            <div class="versions-controls">
              <button id="loadVersionsBtn">Load Versions</button>
              <button id="saveNewVersionBtn">Save New Version</button>
            </div>
            <ul id="versionsList"></ul>
          </div>

          <div class="danger-section">
            <button id="deleteProjectBtn" class="danger">Delete Project</button>
          </div>

          <button id="close-project-manager">Close</button>
        </div>
      </div>

      <!-- MAIN CANVAS -->
      <canvas id="gameCanvas"></canvas>

      <!-- ZOOM CONTROLS (bottom-right) -->
      <div id="zoom-controls" class="floating-panel">
        <button id="zoom-out">-</button>
        <span id="zoom-level">100%</span>
        <button id="zoom-in">+</button>
        <button id="frame-all">Frame</button>
      </div>

      <!-- UNDO/REDO CONTROLS (bottom-left) -->
      <div id="undo-redo-controls" class="floating-panel">
        <button id="undo-btn" title="Undo (Ctrl+Z)">&#8630;</button>
        <button id="redo-btn" title="Redo (Ctrl+Y or Ctrl+Shift+Z)">
          &#8631;
        </button>
      </div>

      <!-- Chat UI -->
      <!-- MOVED to the right side to keep the left side for tools -->
      <div id="chat-container" class="floating-panel">
        <div id="chat-messages"></div>
        <div id="chat-input-row">
          <input type="text" id="chat-input" placeholder="Type a message..." />
          <button id="chat-send-btn">Send</button>
        </div>
      </div>

      <!-- A single global popover for user actions, absolutely positioned -->
      <div id="user-action-popover" class="hidden"></div>
    </div>

    <script type="module" src="js/app.js"></script>
  </body>
</html>


===== ./client/css/style.css =====

/* Basic Reset */
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: sans-serif;
  box-sizing: border-box;
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

#app {
  position: relative;
  width: 100%;
  height: 100%;
}

/* 
  The main canvas remains the same background so the "infinite board" look is not broken.
*/
#gameCanvas {
  display: block;
  width: 100%;
  height: 100%;
  background-color: #222; /* existing dark canvas background */
  cursor: default;
}
#gameCanvas.grabbing {
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

/* FLOATING PANELS */
.floating-panel {
  background-color: #fff;
  color: #333;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  padding: 8px;
  position: absolute;
  z-index: 10;
}

/* Project info panel (top-left) */
#project-info {
  top: 20px;
  left: 20px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  min-width: 140px;
}
#project-info #project-name {
  font-weight: bold;
  cursor: pointer;
}
#open-project-manager {
  background: transparent;
  border: none;
  cursor: pointer;
}

/* Right-top user info panel */
#user-info {
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 8px;
}
#user-name {
  font-weight: bold;
}
#user-circle {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #888;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
}
#user-circle-text {
  font-weight: bold;
}

/* Login dropdown as a floating panel (absolute inside #user-info) */
#login-dropdown {
  top: 48px; /* offset below user-info container */
  right: 0;
  min-width: 220px;
}
#login-dropdown.hidden {
  display: none;
}
.login-row {
  margin-bottom: 6px;
}
.login-row input {
  width: 100%;
  padding: 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
}
.login-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 4px;
}
.login-actions a {
  color: #0066cc;
  text-decoration: none;
  font-size: 0.9em;
}
.login-actions button {
  padding: 6px 10px;
  background-color: #0066cc;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
.login-actions button:hover {
  background-color: #005bb5;
}

/*
  Session users list => left side, under the project info
*/
#session-users-list {
  list-style: none;
  margin: 0;
  padding: 0;
  top: 70px; /* below #project-info */
  left: 20px;
  width: 180px;
  max-height: 150px;
  overflow-y: auto;
}
#session-users-list li {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px;
  border-bottom: 1px solid #eee;
  cursor: default;
}
#session-users-list li:last-child {
  border-bottom: none;
}
.session-user-circle {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  flex-shrink: 0;
}

/*
  TOOLS PALETTE => left side
*/
.left-tools-palette {
  /* place it below the user list to avoid overlap */
  top: 230px;
  left: 20px;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.tool-btn {
  background-color: #f8f8f8;
  border: 1px solid #ddd;
  color: #333;
  border-radius: 4px;
  cursor: pointer;
  min-width: 70px;
  min-height: 32px;
  font-size: 0.85em;
}
.tool-btn:hover {
  background-color: #eee;
}
.tool-btn.selected {
  border: 2px solid #007acc;
}

/* 
  Project Management & Registration modals => 
  semi-opaque backdrop, float above everything
*/
.modal-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
.modal-backdrop.hidden {
  display: none;
}
.modal-content {
  position: relative; /* So it can work with .floating-panel styling */
  max-height: 90vh;
  overflow-y: auto;
  box-sizing: border-box;
}
.modal-content h2 {
  margin-top: 0;
}

/* Buttons in the modals */
button.danger {
  background-color: #e10;
  color: #fff;
  border: none;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
}
button.danger:hover {
  background-color: #c00;
}
#messageContainer {
  margin-bottom: 0.5em;
  min-height: 20px;
  font-weight: bold;
}

/* Zoom controls => bottom-right */
#zoom-controls {
  bottom: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
#zoom-level {
  min-width: 48px;
  text-align: center;
}
#zoom-controls button {
  background-color: #f8f8f8;
  border: 1px solid #ddd;
  color: #333;
  padding: 4px 6px;
  border-radius: 4px;
  cursor: pointer;
}
#zoom-controls button:hover {
  background-color: #eee;
}

/* Undo/Redo controls => bottom-left */
#undo-redo-controls {
  bottom: 20px;
  left: 20px;
  display: flex;
  flex-direction: row;
  gap: 0.5rem;
}
#undo-redo-controls button {
  background-color: #f8f8f8;
  border: 1px solid #ddd;
  color: #333;
  padding: 4px 6px;
  cursor: pointer;
  border-radius: 4px;
}
#undo-redo-controls button:hover {
  background-color: #eee;
}

/*
  Chat container => bottom-right (moved from the left)
*/
#chat-container {
  bottom: 90px;
  right: 20px;
  display: flex;
  flex-direction: column;
  width: 220px;
  height: 220px;
  justify-content: flex-end;
  overflow: hidden;
  padding: 0;
}
#chat-messages {
  flex: 1;
  padding: 8px;
  overflow-y: auto;
  background: #fafafa;
  border-radius: 4px 4px 0 0;
  border: 1px solid #ddd;
  border-bottom: none;
  color: #333;
}
#chat-input-row {
  display: flex;
  gap: 4px;
  padding: 4px;
  border: 1px solid #ddd;
  border-radius: 0 0 4px 4px;
  background: #f8f8f8;
}
#chat-input {
  flex: 1;
  padding: 6px;
  border: 1px solid #ccc;
  border-radius: 4px;
  color: #333;
}
#chat-send-btn {
  padding: 6px 10px;
  background: #0066cc;
  border: none;
  color: #fff;
  cursor: pointer;
  border-radius: 4px;
}
#chat-send-btn:hover {
  background: #005bb5;
}
.chat-message {
  font-size: 0.8em;
}

/* hidden utility */
.hidden {
  display: none !important;
}

/* The user-action popover (for admin/owner actions) */
#user-action-popover {
  position: absolute;
  background: #fff;
  color: #333;
  padding: 8px 10px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  z-index: 9999;
}
#user-action-popover::before {
  content: "";
  position: absolute;
  left: -6px;
  top: 50%;
  transform: translateY(-50%);
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 6px solid #fff;
}
.user-action-item {
  font-size: 0.85em;
  padding: 4px 0;
  cursor: pointer;
}
.user-action-item:hover {
  background: rgba(0, 0, 0, 0.05);
}

/*
  Example "marquee" or ephemeral shape rectangle
*/
.selection-rectangle {
  position: absolute;
  border: 2px solid blue;
  background: rgba(0, 0, 255, 0.2);
  pointer-events: none;
  z-index: 9999;
}


===== ./client/js/canvas.js =====

// ./client/js/canvas.js
import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";

/**
 * client/js/canvas.js
 *
 * Aggregator file so that existing imports/tests still work:
 *   import { initCanvas, handleCanvasMessage, ... } from './canvas.js';
 *
 * This re-exports the real logic from ./canvas/index.js,
 * including the missing handleUserColorUpdate.
 */

export {
  // Main public API
  initCanvas,
  handleCanvasMessage,
  updateCanvasUserId,
  setProjectNameFromServer,
  removeCursorsForMissingUsers,
  handleUserColorUpdate,
} from "./canvas/index.js";

// Optionally export MESSAGE_TYPES if your code/tests expect it from here:
export { MESSAGE_TYPES };


===== ./client/js/app.js =====

// =========================
// FILE: client/js/app.js
// =========================

import { MESSAGE_TYPES } from "../../shared/wsMessageTypes.js";
import {
  initCanvas,
  handleCanvasMessage,
  handleUserColorUpdate,
  setProjectNameFromServer,
  updateCanvasUserId,
  removeCursorsForMissingUsers,
} from "./canvas.js";
import { connectWebSocket, sendWSMessage } from "./wsClient.js";

let token = localStorage.getItem("token") || "";
let currentUser = localStorage.getItem("user")
  ? JSON.parse(localStorage.getItem("user"))
  : null;
let activeUserId = localStorage.getItem("activeUserId");
if (!activeUserId) {
  activeUserId = "anon_" + Math.floor(Math.random() * 999999);
  localStorage.setItem("activeUserId", activeUserId);
}

const isLoggedIn = () => !!token && !!currentUser;
const isCurrentUserAdmin = () => currentUser && currentUser.role === "admin";

let sessionUsers = [];
let ephemeralSessionCode =
  localStorage.getItem("sessionCode") || "defaultSession";

// DOM references
const projectNameEl = document.getElementById("project-name");
const openPMBtn = document.getElementById("open-project-manager");
const pmModal = document.getElementById("project-manager-modal");
const closePMBtn = document.getElementById("close-project-manager");
const loadVersionsBtn = document.getElementById("loadVersionsBtn");
const saveNewVersionBtn = document.getElementById("saveNewVersionBtn");
const deleteProjectBtn = document.getElementById("deleteProjectBtn");
const messageContainer = document.getElementById("messageContainer");

const userInfoPanel = document.getElementById("user-info");
const userNameSpan = document.getElementById("user-name");
const userCircle = document.getElementById("user-circle");
const userCircleText = document.getElementById("user-circle-text");
const loginDropdown = document.getElementById("login-dropdown");
const loginForm = document.getElementById("loginForm");
const registerLink = document.getElementById("registerLink");
const sessionUsersList = document.getElementById("session-users-list");
const registerModal = document.getElementById("register-modal");
const registerForm = document.getElementById("registerForm");
const registerMessage = document.getElementById("register-message");
const registerCancelBtn = document.getElementById("registerCancelBtn");
const userActionPopover = document.getElementById("user-action-popover");

const undoBtn = document.getElementById("undo-btn");
const redoBtn = document.getElementById("redo-btn");

const chatMessagesDiv = document.getElementById("chat-messages");
const chatInput = document.getElementById("chat-input");
const chatSendBtn = document.getElementById("chat-send-btn");

/** A small wrapper for fetch JSON calls. */
async function fetchJSON(url, method = "GET", bodyObj = null) {
  const fetchOptions = { method, headers: {} };
  if (bodyObj) {
    fetchOptions.headers["Content-Type"] = "application/json";
    fetchOptions.body = JSON.stringify(bodyObj);
  }
  const res = await fetch(url, fetchOptions);
  let data;
  try {
    data = await res.json();
  } catch (err) {
    throw new Error(`Fetch error: ${err.message}`);
  }
  if (!res.ok) {
    throw new Error(data.message || `HTTP ${res.status} - ${res.statusText}`);
  }
  return data;
}

/**
 * A simple helper to display a short message in the top
 * of the project manager or any other container.
 */
function showMessage(msg, isError = false) {
  messageContainer.textContent = msg;
  messageContainer.style.color = isError ? "red" : "green";
  setTimeout(() => {
    if (messageContainer.textContent === msg) {
      messageContainer.textContent = "";
    }
  }, 3000);
}

/** Connect to WS, then doJoinSession once it's open. */
function startWebSocket() {
  connectWebSocket(handleServerMessage, doJoinSession);
}

/** Called after WS is open => send a JOIN_SESSION message. */
function doJoinSession() {
  if (!sendWSMessage) return;
  const userName = currentUser ? currentUser.name : "Anonymous";
  let userRole = isCurrentUserAdmin() ? "admin" : "";

  sendWSMessage({
    type: MESSAGE_TYPES.JOIN_SESSION,
    userId: activeUserId,
    name: userName,
    sessionCode: ephemeralSessionCode,
    userRole,
  });
}

/** Master WS message handler => route by type. */
function handleServerMessage(data) {
  switch (data.type) {
    case MESSAGE_TYPES.SESSION_USERS:
      sessionUsers = data.users || [];
      renderSessionUsers();
      updateLocalUserUI();
      sessionUsers.forEach((u) => {
        handleUserColorUpdate(u.userId, u.name, u.color);
      });
      removeCursorsForMissingUsers(sessionUsers.map((u) => u.userId));
      {
        const me = sessionUsers.find((u) => u.userId === activeUserId);
        if (me) {
          userCircle.style.background = me.color;
          userCircleText.textContent = getInitial(me.name);
        }
      }
      break;

    case MESSAGE_TYPES.PROJECT_NAME_CHANGE: {
      const { newName } = data;
      setProjectNameFromServer(newName);
      restoreNameSpan();
      showMessage(`Renamed to: ${newName}`);
      break;
    }

    case MESSAGE_TYPES.CHAT_MESSAGE:
      appendChatMessage(data.message.userId, data.message.text);
      break;

    case MESSAGE_TYPES.ELEMENT_STATE:
    case MESSAGE_TYPES.CURSOR_UPDATE:
    case MESSAGE_TYPES.CURSOR_UPDATES:
      handleCanvasMessage(data, activeUserId);
      break;

    case MESSAGE_TYPES.KICKED:
      alert("You have been kicked from the session.");
      break;

    case MESSAGE_TYPES.UNDO_REDO_FAILED:
      showMessage(data.reason || "Undo/Redo failed", true);
      break;

    default:
      console.log("Unknown message:", data.type, data);
  }
}

/** Show/hide UI elements if I'm an owner/admin. */
function updateUIVisibility() {
  if (!isLoggedIn()) {
    openPMBtn.style.display = "none";
  } else if (amIOwnerOrAdmin()) {
    openPMBtn.style.display = "inline-block";
  } else {
    openPMBtn.style.display = "none";
  }
}

function getInitial(str) {
  if (!str) return "?";
  return str.trim().charAt(0).toUpperCase();
}

/** Are we ephemeral owner or admin in ephemeral session logic? */
function amIOwnerOrAdmin() {
  const me = sessionUsers.find((u) => u.userId === activeUserId);
  if (!me) return false;
  if (me.globalRole === "admin") return true;
  return me.sessionRole === "owner";
}

/** Called after login/out or user list changes => update user circle, name, etc. */
function updateLocalUserUI() {
  let displayName = currentUser?.name || "Anonymous";
  userNameSpan.textContent = displayName;
  const me = sessionUsers.find((x) => x.userId === activeUserId);
  let finalColor = "#888";
  if (me?.color) {
    finalColor = me.color;
  }
  userCircle.style.background = finalColor;
  userCircleText.textContent = getInitial(displayName);
  updateUIVisibility();
}

function renderSessionUsers() {
  sessionUsersList.innerHTML = "";
  sessionUsers.forEach((u) => {
    const li = document.createElement("li");

    const circle = document.createElement("div");
    circle.classList.add("session-user-circle");
    circle.style.background = u.color;
    li.appendChild(circle);

    const labelSpan = document.createElement("span");
    labelSpan.textContent = `${u.name} ${getRoleEmoji(u)}`;
    if (canManageUser(u)) {
      labelSpan.classList.add("user-name-clickable");
      labelSpan.style.cursor = "pointer";
      labelSpan.addEventListener("click", (evt) => {
        evt.stopPropagation();
        onUserNameClicked(u, labelSpan);
      });
    }
    li.appendChild(labelSpan);

    sessionUsersList.appendChild(li);
  });
}

function getRoleEmoji(u) {
  if (u.globalRole === "admin") return "🪄";
  if (u.sessionRole === "owner") return "🔑";
  if (u.sessionRole === "editor") return "✏️";
  return "";
}

function canManageUser(u) {
  const me = sessionUsers.find((x) => x.userId === activeUserId);
  if (!me) return false;
  const iAmAdmin = me.globalRole === "admin";
  const iAmOwner = me.sessionRole === "owner";
  if (!iAmOwner && !iAmAdmin) return false;
  if (u.userId === me.userId) return false;
  if (u.globalRole === "admin" && !iAmAdmin) return false;
  return true;
}

let openPopoverUserId = null;
function onUserNameClicked(u, labelElem) {
  if (openPopoverUserId === u.userId) {
    hideUserActionPopover();
    return;
  }
  openPopoverUserId = u.userId;
  buildAndPositionPopover(u, labelElem);
}

function buildAndPositionPopover(u, labelElem) {
  userActionPopover.innerHTML = "";
  userActionPopover.classList.remove("hidden");

  if (u.sessionRole === "editor") {
    const removeEd = document.createElement("div");
    removeEd.classList.add("user-action-item");
    removeEd.textContent = "Remove Editor";
    removeEd.addEventListener("click", () => {
      sendWSMessage({
        type: MESSAGE_TYPES.REMOVE_EDITOR,
        userId: activeUserId,
        targetUserId: u.userId,
      });
      hideUserActionPopover();
    });
    userActionPopover.appendChild(removeEd);
  } else {
    if (u.sessionRole !== "owner") {
      const makeEd = document.createElement("div");
      makeEd.classList.add("user-action-item");
      makeEd.textContent = "Make Editor";
      makeEd.addEventListener("click", () => {
        sendWSMessage({
          type: MESSAGE_TYPES.MAKE_EDITOR,
          userId: activeUserId,
          targetUserId: u.userId,
        });
        hideUserActionPopover();
      });
      userActionPopover.appendChild(makeEd);
    }
  }

  if (u.sessionRole !== "owner" && u.globalRole !== "admin") {
    const kickItem = document.createElement("div");
    kickItem.classList.add("user-action-item");
    kickItem.textContent = "Kick User";
    kickItem.addEventListener("click", () => {
      sendWSMessage({
        type: MESSAGE_TYPES.KICK_USER,
        userId: activeUserId,
        targetUserId: u.userId,
      });
      hideUserActionPopover();
    });
    userActionPopover.appendChild(kickItem);
  }

  userActionPopover.style.left = "-9999px";
  userActionPopover.style.top = "-9999px";
  requestAnimationFrame(() => {
    const popRect = userActionPopover.getBoundingClientRect();
    const popHeight = popRect.height;
    const userListRect = sessionUsersList.getBoundingClientRect();
    const labelRect = labelElem.getBoundingClientRect();
    const anchorMidY = (labelRect.top + labelRect.bottom) / 2;
    const offsetX = 10;
    const finalLeft = userListRect.right + offsetX;
    const finalTop = anchorMidY - popHeight / 2;
    userActionPopover.style.left = finalLeft + "px";
    userActionPopover.style.top = finalTop + "px";
  });
}

function hideUserActionPopover() {
  openPopoverUserId = null;
  userActionPopover.classList.add("hidden");
}

document.addEventListener("click", (evt) => {
  if (
    openPopoverUserId &&
    !evt.target.closest("#user-action-popover") &&
    !evt.target.classList.contains("user-name-clickable")
  ) {
    hideUserActionPopover();
  }
});

function doLogout() {
  if (!currentUser) return;
  const oldUserId = "user_" + currentUser.id;
  const newAnonId = "anon_" + Math.floor(Math.random() * 999999);

  sendWSMessage({
    type: MESSAGE_TYPES.DOWNGRADE_USER_ID,
    oldUserId,
    newUserId: newAnonId,
  });

  token = "";
  currentUser = null;
  localStorage.removeItem("token");
  localStorage.removeItem("user");

  activeUserId = newAnonId;
  localStorage.setItem("activeUserId", newAnonId);

  updateCanvasUserId(newAnonId);
  showMessage("You are now anonymous.");
  updateLocalUserUI();
}

// Toggle login dropdown if not logged in, or prompt logout if logged in
userInfoPanel.addEventListener("click", (evt) => {
  if (isLoggedIn()) {
    if (confirm("Log out?")) {
      doLogout();
    }
  } else {
    if (!loginDropdown.contains(evt.target)) {
      loginDropdown.classList.toggle("hidden");
    }
  }
});

// If user clicks outside => close the dropdown
document.addEventListener("click", (evt) => {
  if (
    !loginDropdown.classList.contains("hidden") &&
    !loginDropdown.contains(evt.target) &&
    !userInfoPanel.contains(evt.target)
  ) {
    loginDropdown.classList.add("hidden");
  }
});

loginForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const email = document.getElementById("loginEmail").value.trim();
  const pass = document.getElementById("loginPassword").value;

  try {
    const data = await fetchJSON("/auth/login", "POST", {
      email,
      password: pass,
    });
    token = data.token;
    currentUser = data.user;
    localStorage.setItem("token", token);
    localStorage.setItem("user", JSON.stringify(currentUser));

    const newUserId = "user_" + currentUser.id;
    const oldUserId = activeUserId;
    localStorage.setItem("activeUserId", newUserId);
    activeUserId = newUserId;

    // If previously ephemeral, we upgrade
    if (oldUserId.startsWith("anon_")) {
      sendWSMessage({
        type: MESSAGE_TYPES.UPGRADE_USER_ID,
        oldUserId,
        newUserId,
        newName: currentUser.name,
        newIsAdmin: currentUser.role === "admin",
      });
    }
    updateCanvasUserId(newUserId);
    showMessage("Logged in as " + currentUser.name);
    loginDropdown.classList.add("hidden");
    updateLocalUserUI();
  } catch (err) {
    showMessage(err.message, true);
  }
});

registerLink.addEventListener("click", (e) => {
  e.preventDefault();
  loginDropdown.classList.add("hidden");
  registerModal.classList.remove("hidden");
});

registerForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  registerMessage.textContent = "";

  const name = document.getElementById("regName").value.trim();
  const email = document.getElementById("regEmail").value.trim();
  const password = document.getElementById("regPassword").value;
  const confirmPassword = document.getElementById("regConfirm").value;

  try {
    const data = await fetchJSON("/auth/register", "POST", {
      name,
      email,
      password,
      confirmPassword,
    });
    token = data.token;
    currentUser = data.user;
    localStorage.setItem("token", token);
    localStorage.setItem("user", JSON.stringify(currentUser));

    const newId = "user_" + currentUser.id;
    const oldId = activeUserId;
    localStorage.setItem("activeUserId", newId);
    activeUserId = newId;

    if (oldId.startsWith("anon_")) {
      sendWSMessage({
        type: MESSAGE_TYPES.UPGRADE_USER_ID,
        oldUserId: oldId,
        newUserId: newId,
        newName: currentUser.name,
        newIsAdmin: currentUser.role === "admin",
      });
    }
    updateCanvasUserId(newId);

    registerMessage.textContent = "Registration successful!";
    registerMessage.style.color = "green";
    setTimeout(() => {
      registerModal.classList.add("hidden");
      showMessage("Logged in as " + currentUser.name);
      updateLocalUserUI();
    }, 1000);
  } catch (err) {
    registerMessage.textContent = err.message;
    registerMessage.style.color = "red";
  }
});

registerCancelBtn.addEventListener("click", () => {
  registerModal.classList.add("hidden");
});

openPMBtn.addEventListener("click", () => {
  if (!amIOwnerOrAdmin()) {
    showMessage("Must be owner or admin to open panel.", true);
    return;
  }
  pmModal.classList.remove("hidden");
});
closePMBtn.addEventListener("click", () => pmModal.classList.add("hidden"));

loadVersionsBtn.addEventListener("click", () => {
  showMessage("Version loading not implemented in ephemeral mode.", true);
});
saveNewVersionBtn.addEventListener("click", () => {
  if (!isLoggedIn()) {
    showMessage("You must log in to save a project version.", true);
    return;
  }
  showMessage("Saving ephemeral version not implemented.", true);
});
deleteProjectBtn.addEventListener("click", () => {
  showMessage("Delete ephemeral project not implemented.", true);
});

projectNameEl?.addEventListener("click", () => {
  startEditingProjectName();
});

function startEditingProjectName() {
  if (!projectNameEl) return;
  const input = document.createElement("input");
  input.type = "text";
  input.value = projectNameEl.textContent || "Untitled Project";
  input.id = "edit-project-name";
  projectNameEl.replaceWith(input);
  input.focus();

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      commitNameChange(input.value);
    } else if (e.key === "Escape") {
      revertNameChange();
    }
  });
  input.addEventListener("blur", () => {
    commitNameChange(input.value);
  });
}

function commitNameChange(newName) {
  if (!newName.trim()) {
    revertNameChange();
    return;
  }
  if (!amIOwnerOrAdmin()) {
    showMessage("Only session owner or admin can rename.", true);
    revertNameChange();
    return;
  }
  sendWSMessage({
    type: MESSAGE_TYPES.PROJECT_NAME_CHANGE,
    userId: activeUserId,
    newName,
  });
}

function revertNameChange() {
  const oldInput = document.getElementById("edit-project-name");
  if (!oldInput) return;
  const span = document.createElement("span");
  span.id = "project-name";
  span.title = "Click to edit project name";

  if (
    typeof window.currentProjectName === "string" &&
    window.currentProjectName
  ) {
    span.textContent = window.currentProjectName;
  } else {
    span.textContent = "Untitled Project";
  }
  oldInput.replaceWith(span);
  span.addEventListener("click", () => startEditingProjectName());
}

window.addEventListener("DOMContentLoaded", () => {
  document.addEventListener("contextmenu", (e) => e.preventDefault());
  startWebSocket(); // connect and set up handleServerMessage
  initCanvas(activeUserId);
  updateLocalUserUI();
});

// Undo/Redo buttons
undoBtn?.addEventListener("click", () => {
  sendWSMessage({ type: MESSAGE_TYPES.UNDO, userId: activeUserId });
});
redoBtn?.addEventListener("click", () => {
  sendWSMessage({ type: MESSAGE_TYPES.REDO, userId: activeUserId });
});

// Allow Ctrl+Z or Cmd+Z (metaKey) for Mac
window.addEventListener("keydown", (e) => {
  // Check for Ctrl or Cmd (Meta)
  const ctrlOrCmd = e.ctrlKey || e.metaKey;

  if (ctrlOrCmd && !e.shiftKey && e.key.toLowerCase() === "z") {
    e.preventDefault();
    sendWSMessage({ type: MESSAGE_TYPES.UNDO, userId: activeUserId });
  } else if (
    ctrlOrCmd &&
    ((e.shiftKey && e.key.toLowerCase() === "z") || e.key.toLowerCase() === "y")
  ) {
    e.preventDefault();
    sendWSMessage({ type: MESSAGE_TYPES.REDO, userId: activeUserId });
  }
});

function appendChatMessage(userId, text) {
  if (!chatMessagesDiv) return;
  const div = document.createElement("div");
  div.textContent = `${userId}: ${text}`;
  div.classList.add("chat-message");
  chatMessagesDiv.appendChild(div);
  chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
}

function sendChatMessage() {
  if (!chatInput) return;
  const text = chatInput.value.trim();
  if (!text) return;
  sendWSMessage({
    type: MESSAGE_TYPES.CHAT_MESSAGE,
    userId: activeUserId,
    text,
  });
  chatInput.value = "";
}

chatSendBtn?.addEventListener("click", sendChatMessage);
chatInput?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    sendChatMessage();
  }
});


===== ./client/js/wsClient.js =====

// =========================
// FILE: client/js/wsClient.js
// =========================

let ws = null;

/**
 * connectWebSocket(onMessageCallback, onOpenCallback)
 *   - Creates a WebSocket connection using the same protocol/host as the current page.
 *   - onMessageCallback(data) is called for each incoming message object (JSON-parsed).
 *   - onOpenCallback() is called once when the connection is open.
 */
export function connectWebSocket(onMessageCallback, onOpenCallback) {
  // Dynamically choose ws:// or wss:// based on the page location
  const scheme = window.location.protocol === "https:" ? "wss" : "ws";
  const url = scheme + "://" + window.location.host;

  ws = new WebSocket(url);

  ws.onopen = () => {
    console.log("WebSocket connected.");
    if (typeof onOpenCallback === "function") {
      onOpenCallback();
    }
  };

  ws.onmessage = (evt) => {
    let data;
    try {
      data = JSON.parse(evt.data);
    } catch (err) {
      console.error("WS parse error:", err);
      return;
    }
    if (typeof onMessageCallback === "function") {
      onMessageCallback(data);
    }
  };

  ws.onclose = () => {
    console.log("WebSocket closed.");
    ws = null;
  };
}

/**
 * sendWSMessage(obj)
 *   - Sends the given object as JSON, if the connection is open.
 */
export function sendWSMessage(obj) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    console.warn("WebSocket not open; ignoring message:", obj);
    return;
  }
  ws.send(JSON.stringify(obj));
}


===== ./client/js/canvas/canvasUtils.js =====

// =========================
// FILE: client/js/canvas/canvasUtils.js
// =========================

import { state } from "./canvasState.js";
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { sendWSMessage } from "../../js/wsClient.js"; // New import

export function getCanvas2DContext() {
  const canvas = document.getElementById("gameCanvas");
  if (!canvas) return null;
  return canvas.getContext("2d");
}

export function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

export function boxesOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  return !(ax2 < bx1 || ax1 > bx2 || ay2 < by1 || ay1 > by2);
}

export function getEffectiveMajorSpacing(scale) {
  const BASE_SPACING = 100;
  const L4 = Math.log2(scale) / 2;
  let iPart = Math.floor(L4);
  let frac = L4 - iPart;
  if (frac < 0) {
    frac += 1;
    iPart -= 1;
  }
  const majorSpacing = BASE_SPACING / Math.pow(4, iPart);
  const fraction = frac;
  return { majorSpacing, fraction };
}

/**
 * Replaces the old window.__sendWSMessage usage.
 */
export function sendCursorUpdate(uId, wx, wy) {
  if (!uId) return;
  sendWSMessage({
    type: MESSAGE_TYPES.CURSOR_UPDATE,
    userId: uId,
    x: wx,
    y: wy,
  });
}


===== ./client/js/canvas/canvasCamera.js =====

/**
 * client/js/canvas/canvasCamera.js
 *
 * Controls camera transformations (zoom, pan, 'frame all'), and
 * updates the zoom-level UI whenever scale changes.
 */

import { state } from "./canvasState.js";
import { requestRender } from "./canvasRender.js";

/** Speed constants for wheel & button zoom. Feel free to adjust. */
const WHEEL_ZOOM_SPEED = 0.0015;
const BUTTON_ZOOM_STEP = 0.25;

/** applyZoom => set new scale, update camX/camY so anchor stays pinned, call updateZoomUI. */
function applyZoom(newScale, anchorX, anchorY) {
  const oldScale = state.scale;
  if (newScale === oldScale) return;

  // Convert anchor to world coords at old scale
  const wx = state.camX + anchorX / oldScale;
  const wy = state.camY + anchorY / oldScale;

  state.scale = newScale;
  // Adjust camera so anchor is pinned
  state.camX = wx - anchorX / newScale;
  state.camY = wy - anchorY / newScale;

  updateZoomUI();
  requestRender();
}

/** clampScale => keep scale in [min, max]. */
function clampScale(value) {
  const { minScale, maxScale } = state;
  return Math.max(minScale, Math.min(maxScale, value));
}

/** Called by wheel => zoom, with anchor at pointer. */
export function handleWheelZoom(e, canvas) {
  e.preventDefault();
  const factor = Math.exp(-e.deltaY * WHEEL_ZOOM_SPEED);
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  const newScale = clampScale(state.scale * factor);
  applyZoom(newScale, sx, sy);
}

/** For the +/- zoom buttons => anchor around center. */
export function zoomAroundCenter(step) {
  const canvas = document.getElementById("gameCanvas");
  if (!canvas) return;
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;
  const newScale = clampScale(state.scale + step);
  applyZoom(newScale, cw / 2, ch / 2);
}

/**
 * frameAllElements => if the user has selection, frame that;
 * otherwise frame all elements. Then call updateZoomUI.
 */
export function frameAllElements() {
  if (!state.elements.length) return;
  let minX = Infinity,
    maxX = -Infinity;
  let minY = Infinity,
    maxY = -Infinity;

  // If there's a selection, frame just that. Else frame everything.
  const targets =
    state.selectedElementIds.length > 0
      ? state.elements.filter((el) => state.selectedElementIds.includes(el.id))
      : state.elements;

  for (const el of targets) {
    minX = Math.min(minX, el.x);
    maxX = Math.max(maxX, el.x + el.w);
    minY = Math.min(minY, el.y);
    maxY = Math.max(maxY, el.y + el.h);
  }
  const w = maxX - minX;
  const h = maxY - minY;
  if (w <= 0 || h <= 0) return;

  const canvas = document.getElementById("gameCanvas");
  if (!canvas) return;
  const cw = canvas.clientWidth,
    ch = canvas.clientHeight;
  const margin = 50;
  const scaleX = (cw - margin * 2) / w;
  const scaleY = (ch - margin * 2) / h;
  const newScale = clampScale(Math.min(scaleX, scaleY));

  const cx = minX + w / 2;
  const cy = minY + h / 2;

  state.scale = newScale;
  state.camX = cx - cw / (2 * newScale);
  state.camY = cy - ch / (2 * newScale);

  updateZoomUI();
  requestRender();
}

/** updateZoomUI => set #zoom-level text to e.g. "125%" */
function updateZoomUI() {
  const el = document.getElementById("zoom-level");
  if (el) {
    el.textContent = `${Math.round(state.scale * 100)}%`;
  }
}


===== ./client/js/canvas/canvasState.js =====


/**
 * @file canvasState.js
 * @description
 * Manages the global state for the canvas module, including element data,
 * selected elements, user input flags, camera transforms, and the new
 * oriented bounding box properties for group rotation/resizing.
 *
 * Key features:
 * - Maintains the list of elements (shapes, text, etc.).
 * - Tracks the camera position/scale, selection, locked offsets, rotation, etc.
 * - Holds ephemeral states like marquee selection, shape creation, group rotation.
 *
 * @notes
 * - We added selectionCenter, selectionAngle, shapeAngleOffsets, and
 *   selectionBounds to support oriented bounding box (group rotation/resize).
 * - selectionBounds is the bounding box in local (unrotated) coordinates.
 *   The bounding box is oriented by selectionAngle around selectionCenter.
 */

// We maintain a single state object for convenience.
// Code in canvasEvents.js and canvasTools.js manipulates this state directly.
export const state = {
  // Camera / viewport
  camX: 0,
  camY: 0,
  scale: 1,

  // Input flags
  shiftDown: false,
  isPanning: false,
  isDragging: false,
  isResizing: false,
  isRotating: false,
  isMarqueeSelecting: false,

  // Elements + selection
  elements: [],                // All shapes/elements on the canvas
  selectedElementIds: [],      // Which element IDs are selected
  lockedOffsets: {},           // For dragging: keyed by elementId => {dx, dy}

  // Marquee
  marqueeStart: { xCanvas: 0, yCanvas: 0, xWorld: 0, yWorld: 0 },
  marqueeEnd: { xCanvas: 0, yCanvas: 0, xWorld: 0, yWorld: 0 },

  // Shape creation
  creationState: null, // {active, tool, startWX, startWY, curWX, curWY}

  // Rotation
  rotationSnapshot: [],        // Array of {id, angle}, storing original angles
  rotationCenter: null,        // {x, y} center in world coords
  rotationPointerStart: 0,     // angle of pointer relative to center at start

  // Resizing
  activeHandle: null,          // which handle name is active
  boundingBoxAtDragStart: null,// for group or single shape bounding box
  shapesSnapshot: [],          // snapshot for resizing {id, x, y, w, h, relX, relY}

  // Collaboration
  localUserId: null,
  remoteCursors: new Map(),    // userId => {x, y} in world coords
  userInfoMap: new Map(),      // userId => {name, color}

  // Group transform (or single element) bounding box data:
  //  - selectionCenter: group center in world coords
  //  - selectionAngle: the "group angle" used to rotate bounding box
  //  - shapeAngleOffsets: per-element offset angles from the group angle
  //  - selectionBounds: bounding box in "local" coords after we de-rotate
  selectionCenter: { x: 0, y: 0 },
  selectionAngle: 0,
  shapeAngleOffsets: {}, // keyed by elementId => angle offset from group angle
  selectionBounds: { x: 0, y: 0, w: 0, h: 0 },
};


===== ./client/js/canvas/index.js =====

/**
 * client/js/canvas/index.js
 *
 * The main orchestrator that initializes the canvas, sets up
 * event listeners for the Zoom In / Zoom Out / Frame All buttons,
 * and re-exports relevant functions.
 */

import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { state, setCurrentProjectName } from "./canvasState.js";
import { initPointerAndKeyEvents } from "./canvasEvents.js";
import {
  setLocalUserId,
  createOrUpdateElementsFromServer,
  removeObsoleteSelections,
  handleCursorData,
  removeStaleRemoteCursors,
} from "./canvasTools.js";
import { requestRender } from "./canvasRender.js";
import { handleUserColorUpdate } from "./canvasUsers.js";
import { zoomAroundCenter, frameAllElements } from "./canvasCamera.js";

/**
 * Initialize the canvas with the current userId,
 * attach event handlers, set up the tools palette, etc.
 */
export function initCanvas(initialUserId) {
  setLocalUserId(initialUserId);

  // Attach pointer events & key events
  initPointerAndKeyEvents();

  // Initialize the Tools Palette (click => "selected" class)
  initToolsPalette();

  // Wire up zoom-in, zoom-out, frame-all
  setupZoomUI();

  // Start initial render
  requestRender();
}

/** Handle a canvas-related message from the server. */
export function handleCanvasMessage(data, myUserId) {
  switch (data.type) {
    case MESSAGE_TYPES.ELEMENT_STATE: {
      createOrUpdateElementsFromServer(data.elements);
      if (typeof data.projectName === "string") {
        setCurrentProjectName(data.projectName);
        window.currentProjectName = data.projectName; // fallback for UI
      }
      // Remove local selections that are invalid
      removeObsoleteSelections(myUserId);
      break;
    }
    case MESSAGE_TYPES.CURSOR_UPDATE:
    case MESSAGE_TYPES.CURSOR_UPDATES:
      handleCursorData(data, myUserId);
      break;
    default:
      // Other server messages (move, grab, etc.)
      // get handled indirectly by the local pointer logic or do nothing.
      break;
  }
  requestRender();
}

/** If local user ID changes (e.g. login/out), update references. */
export function updateCanvasUserId(newId) {
  setLocalUserId(newId);
}

/** The server can rename the project => store it. */
export function setProjectNameFromServer(newName) {
  setCurrentProjectName(newName);
  window.currentProjectName = newName;
  requestRender();
}

/** Remove remote cursors for user IDs not in the new user list. */
export function removeCursorsForMissingUsers(currentUserIds) {
  removeStaleRemoteCursors(currentUserIds);
  requestRender();
}

// Re-export so other code can do handleUserColorUpdate
export { handleUserColorUpdate };

/* ------------------------------------------------------------------
   Tools Palette
------------------------------------------------------------------ */
function initToolsPalette() {
  const palette = document.getElementById("tools-palette");
  if (!palette) return;
  const buttons = palette.querySelectorAll(".tool-btn");
  buttons.forEach((btn) => {
    btn.addEventListener("click", () => {
      buttons.forEach((b) => b.classList.remove("selected"));
      btn.classList.add("selected");
    });
  });
}

/* ------------------------------------------------------------------
   Zoom UI => wire up the #zoom-in, #zoom-out, #frame-all buttons
------------------------------------------------------------------ */
function setupZoomUI() {
  const zoomInBtn = document.getElementById("zoom-in");
  const zoomOutBtn = document.getElementById("zoom-out");
  const frameBtn = document.getElementById("frame-all");

  if (zoomInBtn) {
    zoomInBtn.addEventListener("click", () => {
      zoomAroundCenter(+0.25);
    });
  }
  if (zoomOutBtn) {
    zoomOutBtn.addEventListener("click", () => {
      zoomAroundCenter(-0.25);
    });
  }
  if (frameBtn) {
    frameBtn.addEventListener("click", () => {
      frameAllElements();
    });
  }
}


===== ./client/js/canvas/canvasUsers.js =====

/**
 * client/js/canvas/canvasUsers.js
 *
 * Restores the missing handleUserColorUpdate function
 * for setting each user's color/name in userInfoMap.
 */

import { state } from "./canvasState.js";

/**
 * handleUserColorUpdate(userId, name, color):
 *   - Updates the userInfoMap so remote cursors
 *     or other UI can display the correct color & name.
 */
export function handleUserColorUpdate(userId, name, color) {
  state.userInfoMap.set(userId, { name, color });
}


===== ./client/js/canvas/canvasEvents.js =====


/**
 * @file canvasEvents.js
 * @description
 * Sets up and manages low-level pointer and keyboard events on the canvas.
 * Delegates logic to canvasTools.js for selection, rotation, resizing, etc.
 *
 * Key features:
 * - Pointer down/move/up logic
 * - Distinguishes panning vs. selection vs. marquee vs. resizing vs. rotating
 * - Global keyboard shortcuts (Esc, Delete, etc.)
 *
 * @notes
 * - We replaced direct calls to the old axis-aligned bounding box handles with
 *   new oriented bounding box checks in canvasTools.js (hitTestOriented...).
 * - The structure of pointerdown for resizing/rotation is now updated
 *   to consider orientation.
 */

import { state } from "./canvasState.js";
import { requestRender } from "./canvasRender.js";
import { handleWheelZoom } from "./canvasCamera.js";
import {
  onPointerDownSelectOrCreate,
  onPointerMoveCommon,
  onPointerUpCommon,
  onPointerCancelOrLeaveCommon,
  hitTestOrientedResizeHandles,
  startResizing,
  updateResizing,
  endResizing,
} from "./canvasTools.js";
import { sendCursorUpdate } from "./canvasUtils.js";

export function initPointerAndKeyEvents() {
  const canvas = document.getElementById("gameCanvas");
  if (!canvas) return;

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  canvas.addEventListener("pointerdown", onPointerDown);
  canvas.addEventListener("pointermove", onPointerMove);
  canvas.addEventListener("pointerup", onPointerUp);
  canvas.addEventListener("pointercancel", onPointerCancelOrLeave);
  canvas.addEventListener("pointerleave", onPointerCancelOrLeave);

  canvas.addEventListener("wheel", (e) => handleWheelZoom(e, canvas), {
    passive: false,
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Shift") {
      state.shiftDown = true;
    }
  });
  window.addEventListener("keyup", (e) => {
    if (e.key === "Shift") {
      state.shiftDown = false;
    }
  });

  // For Escape / Delete / Backspace
  window.addEventListener("keydown", handleGlobalKeyDown);
}

/**
 * Resize the canvas to match its CSS pixel size * devicePixelRatio.
 */
function resizeCanvas() {
  const canvas = document.getElementById("gameCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const cssWidth = canvas.clientWidth;
  const cssHeight = canvas.clientHeight;
  canvas.width = cssWidth * window.devicePixelRatio;
  canvas.height = cssHeight * window.devicePixelRatio;
  ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
  requestRender();
}

/**
 * PointerDown event handler
 */
function onPointerDown(e) {
  const canvas = e.currentTarget;
  if (e.button === 1 || e.button === 2) {
    // Middle or right => panning
    state.isPanning = true;
    return;
  }
  if (e.button === 0) {
    // Left click => possible resizing, rotation, or selection
    if (!state.isResizing) {
      const handle = hitTestOrientedResizeHandles(e, canvas);
      if (handle) {
        // Start resizing
        startResizing(handle, e, canvas);
        return;
      }
    }
    onPointerDownSelectOrCreate(e, canvas);
  }
}

/**
 * PointerMove event handler
 */
function onPointerMove(e) {
  const canvas = e.currentTarget;

  if (state.isPanning && e.buttons & (2 | 4)) {
    // doPan
    const dx = e.movementX;
    const dy = e.movementY;
    state.camX -= dx / state.scale;
    state.camY -= dy / state.scale;
    requestRender();
    sendLocalCursor(e, canvas);
    return;
  }

  if (state.isResizing && e.buttons & 1) {
    // Update resizing
    updateResizing(e, canvas);
    requestRender();
    sendLocalCursor(e, canvas);
    return;
  }

  // Otherwise normal pointer-move logic
  onPointerMoveCommon(e, canvas);
  requestRender();
  sendLocalCursor(e, canvas);
}

/**
 * PointerUp event handler
 */
function onPointerUp(e) {
  const canvas = e.currentTarget;
  if (e.button === 1 || e.button === 2) {
    state.isPanning = false;
    return;
  }
  if (state.isResizing && e.button === 0) {
    endResizing(false); // finalize
    requestRender();
    return;
  }
  onPointerUpCommon(e, canvas);
  requestRender();
}

/**
 * PointerCancel/Leave event handler
 */
function onPointerCancelOrLeave(e) {
  if (state.isResizing) {
    endResizing(true); // force-cancel
    requestRender();
    return;
  }
  onPointerCancelOrLeaveCommon(e);
  requestRender();
}

/**
 * Global keydown event handler for ESC, Delete, etc.
 */
function handleGlobalKeyDown(e) {
  // Skip if focused on input/textarea
  const tag = document.activeElement?.tagName?.toLowerCase();
  if (tag === "input" || tag === "textarea") {
    return;
  }

  switch (e.key) {
    case "Escape":
      if (state.creationState?.active) {
        state.creationState.active = false;
      } else if (state.isResizing) {
        endResizing(true);
      } else {
        // Deselect
        import("./canvasTools.js").then((module) => {
          module.deselectAll();
        });
      }
      break;
    case "Delete":
    case "Backspace":
      // Avoid going back in browser history
      e.preventDefault();
      if (state.selectedElementIds.length) {
        import("./canvasTools.js").then((module) => {
          module.sendDeleteElements(state.selectedElementIds);
          state.selectedElementIds = [];
        });
      }
      break;
    default:
      // Let other combos pass
      break;
  }
}

/**
 * Sends local cursor data to server for other collaborators
 */
function sendLocalCursor(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const scrX = e.clientX - rect.left;
  const scrY = e.clientY - rect.top;
  const wx = state.camX + scrX / state.scale;
  const wy = state.camY + scrY / state.scale;
  sendCursorUpdate(state.localUserId, wx, wy);
}


===== ./client/js/canvas/canvasRender.js =====


/**
 * @file canvasRender.js
 * @description
 * Provides the main rendering loop for the canvas, including grid,
 * elements, oriented bounding box, marquee, and remote cursors.
 *
 * Key features:
 * - requestRender() for scheduling an animation frame
 * - render() method that draws background, grid, shapes, selection box, etc.
 * - Now draws the oriented bounding box (rotated around state.selectionAngle).
 *
 * @notes
 * - The bounding box is drawn by applying the same transform (translate + rotate)
 *   used for group rotation. We then draw the axis-aligned box in local coords.
 */

import { state } from "./canvasState.js";
import { getCanvas2DContext, getEffectiveMajorSpacing } from "./canvasUtils.js";

let animId = null;

/**
 * requestRender => queue up a requestAnimationFrame if not already queued
 */
export function requestRender() {
  if (!animId) {
    animId = requestAnimationFrame(render);
  }
}

/**
 * Main render function
 */
function render() {
  animId = null;
  const ctx = getCanvas2DContext();
  if (!ctx) return;

  // Clear entire canvas
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.restore();

  fillBackground(ctx);
  drawGrid(ctx);

  // Setup camera
  ctx.save();
  ctx.translate(-state.camX * state.scale, -state.camY * state.scale);
  ctx.scale(state.scale, state.scale);

  // Draw shapes
  drawAllElements(ctx);

  // Draw bounding box
  if (state.selectedElementIds.length && !state.creationState?.active) {
    drawOrientedBoundingBox(ctx);
  }

  // Ephemeral creation
  drawEphemeralCreation(ctx);

  // done with world transform
  ctx.restore();

  // Marquee in screen coords
  if (state.isMarqueeSelecting) {
    drawMarquee(ctx);
  }

  // Remote cursors in screen coords
  drawRemoteCursors(ctx);
}

/**
 * Fill background with a neutral color
 */
function fillBackground(ctx) {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = "#F0F0F0";
  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.restore();
}

/**
 * Draw grid lines in world coords
 */
function drawGrid(ctx) {
  ctx.save();
  ctx.translate(-state.camX * state.scale, -state.camY * state.scale);
  ctx.scale(state.scale, state.scale);

  const cw = ctx.canvas.clientWidth / state.scale;
  const ch = ctx.canvas.clientHeight / state.scale;
  const { majorSpacing, fraction } = getEffectiveMajorSpacing(state.scale);

  const startX = Math.floor(state.camX / majorSpacing) * majorSpacing;
  const endX = Math.ceil((state.camX + cw) / majorSpacing) * majorSpacing;
  const startY = Math.floor(state.camY / majorSpacing) * majorSpacing;
  const endY = Math.ceil((state.camY + ch) / majorSpacing) * majorSpacing;

  ctx.strokeStyle = "rgb(220,220,220)";
  ctx.lineWidth = 1 / state.scale;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += majorSpacing) {
    ctx.moveTo(x, startY);
    ctx.lineTo(x, endY);
  }
  for (let y = startY; y <= endY; y += majorSpacing) {
    ctx.moveTo(startX, y);
    ctx.lineTo(endX, y);
  }
  ctx.stroke();

  if (fraction > 0) {
    ctx.strokeStyle = `rgba(230,230,230,${fraction})`;
    const subSpacing = majorSpacing / 4;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += majorSpacing) {
      for (let i = 1; i < 4; i++) {
        const xx = x + i * subSpacing;
        ctx.moveTo(xx, startY);
        ctx.lineTo(xx, endY);
      }
    }
    for (let y = startY; y <= endY; y += majorSpacing) {
      for (let i = 1; i < 4; i++) {
        const yy = y + i * subSpacing;
        ctx.moveTo(startX, yy);
        ctx.lineTo(endX, yy);
      }
    }
    ctx.stroke();
  }

  ctx.restore();
}

/**
 * Draw all shapes with their rotation
 */
function drawAllElements(ctx) {
  for (const el of state.elements) {
    ctx.save();

    const angleDeg = el.angle || 0;
    const angleRad = (angleDeg * Math.PI) / 180;
    const cx = el.x + el.w / 2;
    const cy = el.y + el.h / 2;

    ctx.translate(cx, cy);
    ctx.rotate(angleRad);
    ctx.translate(-el.w / 2, -el.h / 2);

    if (el.shape === "ellipse") {
      ctx.beginPath();
      ctx.ellipse(0, 0, el.w / 2, el.h / 2, 0, 0, Math.PI * 2);
      ctx.fillStyle = "#CCC";
      ctx.fill();
    } else if (el.shape === "text") {
      ctx.fillStyle = "#FFE";
      ctx.fillRect(0, 0, el.w, el.h);
      ctx.fillStyle = "#333";
      ctx.font = "14px sans-serif";
      ctx.fillText("Text", 5, el.h / 2 + 5);
    } else {
      // rectangle
      ctx.fillStyle = "#CCC";
      ctx.fillRect(0, 0, el.w, el.h);
    }

    // Outline if locked by someone else
    if (el.lockedBy && el.lockedBy !== state.localUserId) {
      const info = state.userInfoMap.get(el.lockedBy);
      const outlineColor = info?.color || "#FFA500";
      ctx.lineWidth = 2;
      ctx.strokeStyle = outlineColor;
      if (el.shape === "ellipse") {
        ctx.beginPath();
        ctx.ellipse(0, 0, el.w / 2, el.h / 2, 0, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        ctx.strokeRect(0, 0, el.w, el.h);
      }
    }

    ctx.restore();
  }
}

/**
 * Draw the oriented bounding box for the current selection
 */
function drawOrientedBoundingBox(ctx) {
  if (!state.selectedElementIds.length) return;
  const { x, y, w, h } = state.selectionBounds;
  if (w <= 0 || h <= 0) return;

  const cx = state.selectionCenter.x;
  const cy = state.selectionCenter.y;
  const angleDeg = state.selectionAngle;
  const angleRad = (angleDeg * Math.PI) / 180;

  ctx.save();
  // Move to selection center, rotate, then draw the local bounding box
  ctx.translate(cx, cy);
  ctx.rotate(angleRad);

  // bounding box
  ctx.strokeStyle = "rgba(0,0,255,0.8)";
  ctx.lineWidth = 2 / state.scale;
  ctx.strokeRect(x, y, w, h);

  // corners
  const cornerRadius = 6 / state.scale;
  const cornerStroke = 2 / state.scale;
  const corners = [
    { cx: x, cy: y },
    { cx: x + w, cy: y },
    { cx: x + w, cy: y + h },
    { cx: x, cy: y + h },
  ];
  ctx.fillStyle = "#FFF";
  ctx.strokeStyle = "#000";
  ctx.lineWidth = cornerStroke;
  for (const c of corners) {
    ctx.beginPath();
    ctx.ellipse(c.cx, c.cy, cornerRadius, cornerRadius, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // rotation handle at top-center, 20 px above the bounding box
  const rotHandleY = y - 20 / state.scale;
  const rotHandleX = x + w / 2;
  ctx.beginPath();
  ctx.moveTo(rotHandleX, rotHandleY);
  ctx.lineTo(rotHandleX, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.ellipse(
    rotHandleX,
    rotHandleY,
    6 / state.scale,
    6 / state.scale,
    0,
    0,
    Math.PI * 2,
  );
  ctx.fill();
  ctx.stroke();

  ctx.restore();
}

/**
 * Draw ephemeral creation box
 */
function drawEphemeralCreation(ctx) {
  if (!state.creationState?.active) return;
  const { tool, startWX, startWY, curWX, curWY } = state.creationState;
  let x = Math.min(startWX, curWX);
  let y = Math.min(startWY, curWY);
  let w = Math.abs(curWX - startWX);
  let h = Math.abs(curWY - startWY);

  if (state.shiftDown && (tool === "rectangle" || tool === "ellipse")) {
    const side = Math.max(w, h);
    w = side;
    h = side;
  }
  if (tool === "text") {
    h = 30;
  }
  if (w < 1 && h < 1) return;

  ctx.save();
  ctx.beginPath();
  if (tool === "ellipse") {
    ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
  } else {
    ctx.rect(x, y, w, h);
  }
  ctx.fillStyle = "rgba(255,0,0,0.2)";
  ctx.fill();
  ctx.lineWidth = 2 / state.scale;
  ctx.strokeStyle = "red";
  ctx.stroke();
  ctx.restore();
}

/**
 * Draw marquee in screen coords
 */
function drawMarquee(ctx) {
  const rx = Math.min(state.marqueeStart.xCanvas, state.marqueeEnd.xCanvas);
  const ry = Math.min(state.marqueeStart.yCanvas, state.marqueeEnd.yCanvas);
  const rw = Math.abs(state.marqueeEnd.xCanvas - state.marqueeStart.xCanvas);
  const rh = Math.abs(state.marqueeEnd.yCanvas - state.marqueeStart.yCanvas);

  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.beginPath();
  ctx.rect(rx, ry, rw, rh);
  ctx.fillStyle = "rgba(0,0,255,0.2)";
  ctx.fill();
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

/**
 * Draw remote cursors in screen coords
 */
function drawRemoteCursors(ctx) {
  ctx.save();
  for (const [uId, pos] of state.remoteCursors.entries()) {
    if (uId === state.localUserId) continue;
    const info = state.userInfoMap.get(uId);
    const outlineColor = info?.color || "#FFA500";

    const sx = (pos.x - state.camX) * state.scale;
    const sy = (pos.y - state.camY) * state.scale;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, 14);
    ctx.lineTo(4, 10);
    ctx.lineTo(6, 14);
    ctx.lineTo(8, 12);
    ctx.lineTo(5, 7);
    ctx.lineTo(9, 3);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.strokeStyle = outlineColor;
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.font = "6px sans-serif";
    ctx.fillStyle = "#000";
    const label = info?.name || uId;
    ctx.fillText(label, 10, 6);

    ctx.restore();
  }
  ctx.restore();
}


===== ./client/js/canvas/canvasTools.js =====

/**
 * @file canvasTools.js
 * @description
 * Contains functions for creation, selection, rotation, and resizing of elements,
 * including logic for an oriented bounding box representing either a single element
 * or a group of elements. The bounding box is defined by state.selectionCenter,
 * state.selectionAngle, and state.selectionBounds in "local" coords.
 *
 * Key features:
 * - Oriented bounding box: rotation and resizing happen in local bounding box space.
 * - Single-element or multi-element selection is treated as a group.
 * - Each shape maintains its own 'angle' property, but we also track a 'selectionAngle'
 *   and 'shapeAngleOffsets' for correct group rotation.
 *
 * @dependencies
 * - state from canvasState.js
 * - requestRender from canvasRender.js
 * - wsClient for sending element changes to the server
 *
 * @notes
 * - The "oriented bounding box" approach means we transform pointer coords
 *   into local bounding box space for hit-testing corners/edges/rotation handle.
 * - For resizing in local space, we scale/translate each shape accordingly.
 */

import { state } from "./canvasState.js";
import { requestRender } from "./canvasRender.js";
import { MESSAGE_TYPES } from "../../../shared/wsMessageTypes.js";
import { boxesOverlap, sendCursorUpdate } from "./canvasUtils.js";
import { sendWSMessage } from "../../js/wsClient.js";

/* ------------------------------------------------------------------
   Helper: compute selection bounding box & center with orientation
------------------------------------------------------------------ */

/**
 * Compute & store in state:
 *  - selectionCenter (average center of selected shapes)
 *  - selectionAngle (for group rotation)
 *  - shapeAngleOffsets (angle difference from selectionAngle for each element)
 *  - selectionBounds (in local space) => an axis-aligned box that encloses all shapes
 *    after we transform them by ( -selectionCenter, -selectionAngle ).
 */
export function updateSelectionOrientedBox() {
  if (!state.selectedElementIds.length) {
    state.selectionCenter = { x: 0, y: 0 };
    state.selectionAngle = 0;
    state.shapeAngleOffsets = {};
    state.selectionBounds = { x: 0, y: 0, w: 0, h: 0 };
    return;
  }

  // 1) Gather the bounding corners of each shape in world coords,
  //    also track shape centers & angles for group rotation.
  const selEls = state.elements.filter((el) =>
    state.selectedElementIds.includes(el.id),
  );
  let sumX = 0;
  let sumY = 0;
  for (const el of selEls) {
    const cx = el.x + el.w / 2;
    const cy = el.y + el.h / 2;
    sumX += cx;
    sumY += cy;
  }

  // 2) selectionCenter => average center
  const count = selEls.length;
  const centerX = sumX / count;
  const centerY = sumY / count;
  state.selectionCenter = { x: centerX, y: centerY };

  // 3) selectionAngle => for now, let's pick the average angle (simple approach).
  //    If there's only one shape, it is that shape's angle.
  //    If multiple shapes, we do the average of their angles.
  let angleSum = 0;
  for (const el of selEls) {
    angleSum += el.angle || 0;
  }
  let groupAngle = angleSum / count;

  // Optionally, we can clamp or mod 360
  groupAngle = normalizeAngle(groupAngle);
  state.selectionAngle = groupAngle;

  // 4) shapeAngleOffsets => shape.angle - groupAngle
  state.shapeAngleOffsets = {};
  for (const el of selEls) {
    let off = (el.angle || 0) - groupAngle;
    // unify angles to [-180..180] or 0..360, whichever
    off = normalizeAngle(off);
    state.shapeAngleOffsets[el.id] = off;
  }

  // 5) Now compute the oriented bounding box (in "local" coords),
  //    by transforming each shape corner into local space
  //    local space transform = [translate by -selectionCenter] then rotate by -groupAngle
  let minX = Infinity,
    minY = Infinity,
    maxX = -Infinity,
    maxY = -Infinity;

  for (const el of selEls) {
    // each shape has corners, but we must consider that shape is itself rotated
    // by (el.angle). We'll handle that by taking the shape's corners in world coords
    // (with el.angle), then transform them by the group transform.
    const corners = getWorldSpaceShapeCorners(el);
    for (const c of corners) {
      // translate
      const tx = c.x - centerX;
      const ty = c.y - centerY;
      // rotate by -groupAngle
      const rad = (-groupAngle * Math.PI) / 180;
      const rx = tx * Math.cos(rad) - ty * Math.sin(rad);
      const ry = tx * Math.sin(rad) + ty * Math.cos(rad);

      if (rx < minX) minX = rx;
      if (ry < minY) minY = ry;
      if (rx > maxX) maxX = rx;
      if (ry > maxY) maxY = ry;
    }
  }

  const w = maxX - minX;
  const h = maxY - minY;

  state.selectionBounds = {
    x: minX,
    y: minY,
    w: w,
    h: h,
  };
}

/**
 * Return the corners of a shape in absolute world coords, considering shape.angle.
 * The shape is drawn with center at (x + w/2, y + h/2).
 */
function getWorldSpaceShapeCorners(el) {
  const angleDeg = el.angle || 0;
  const angleRad = (angleDeg * Math.PI) / 180;
  const cx = el.x + el.w / 2;
  const cy = el.y + el.h / 2;

  // corners in local space (relative to shape center),
  // unrotated shape corners:
  const halfW = el.w / 2;
  const halfH = el.h / 2;
  const corners = [
    { x: -halfW, y: -halfH }, // top-left
    { x: halfW, y: -halfH }, // top-right
    { x: halfW, y: halfH }, // bottom-right
    { x: -halfW, y: halfH }, // bottom-left
  ];
  // rotate + translate
  const worldCorners = corners.map((pt) => {
    const rx = pt.x * Math.cos(angleRad) - pt.y * Math.sin(angleRad);
    const ry = pt.x * Math.sin(angleRad) + pt.y * Math.cos(angleRad);
    return {
      x: rx + cx,
      y: ry + cy,
    };
  });
  return worldCorners;
}

function normalizeAngle(aDeg) {
  // map angle to [0..360)
  let angle = aDeg % 360;
  if (angle < 0) angle += 360;
  return angle;
}

/* ------------------------------------------------------------------
   Oriented bounding box: hit-test corners, edges, etc.
------------------------------------------------------------------ */

/**
 * We call this in onPointerDown to see if the user is clicking on
 * any resize handle in the oriented bounding box. If so, return handle name
 * so we can start resizing. If user clicks near the rotation handle,
 * we do rotation in startRotating. (We'll put rotation handle near top edge.)
 */
export function hitTestOrientedResizeHandles(e, canvas) {
  if (!canTransformSelection()) return null;
  if (!state.selectedElementIds.length) return null;

  // transform pointer to local bounding box coords
  const { lx, ly } = getLocalPointer(e, canvas);
  const { x, y, w, h } = state.selectionBounds;
  if (w <= 0 || h <= 0) return null;

  // 1) Check rotation handle first
  //    We'll place it top-middle, a bit above the bounding box in local coords
  const handleRadius = 10 / state.scale;
  const topX = x + w / 2;
  const topY = y; // top edge in local coords
  const rotHandleY = topY - 20 / state.scale; // 20 px above the top edge
  const dx = lx - topX;
  const dy = ly - rotHandleY;
  if (dx * dx + dy * dy <= handleRadius * handleRadius) {
    return "rotate-handle";
  }

  // 2) Check corners
  // We'll use a radius of 8 px in local space for corners
  const cornerRadius = 8 / state.scale;
  const corners = [
    { cx: x, cy: y, name: "top-left" },
    { cx: x + w, cy: y, name: "top-right" },
    { cx: x + w, cy: y + h, name: "bottom-right" },
    { cx: x, cy: y + h, name: "bottom-left" },
  ];
  for (const c of corners) {
    const ddx = lx - c.cx;
    const ddy = ly - c.cy;
    if (ddx * ddx + ddy * ddy <= cornerRadius * cornerRadius) {
      return c.name;
    }
  }

  // 3) Check edges
  // We allow a small threshold of 6 px in local coords
  const edgeTol = 6 / state.scale;

  // top edge
  if (ly >= y - edgeTol && ly <= y + edgeTol && lx >= x && lx <= x + w) {
    return "top";
  }
  // bottom edge
  if (
    ly >= y + h - edgeTol &&
    ly <= y + h + edgeTol &&
    lx >= x &&
    lx <= x + w
  ) {
    return "bottom";
  }
  // left edge
  if (lx >= x - edgeTol && lx <= x + edgeTol && ly >= y && ly <= y + h) {
    return "left";
  }
  // right edge
  if (
    lx >= x + w - edgeTol &&
    lx <= x + w + edgeTol &&
    ly >= y &&
    ly <= y + h
  ) {
    return "right";
  }

  return null;
}

/**
 * Transform pointer from screen coords => world coords => local bounding box coords
 */
function getLocalPointer(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;

  // 1) world coords
  const wx = state.camX + sx / state.scale;
  const wy = state.camY + sy / state.scale;

  // 2) local bounding box coords => translate by -selectionCenter, rotate by -selectionAngle
  const cx = state.selectionCenter.x;
  const cy = state.selectionCenter.y;
  let tx = wx - cx;
  let ty = wy - cy;
  const rad = (-state.selectionAngle * Math.PI) / 180;
  const rx = tx * Math.cos(rad) - ty * Math.sin(rad);
  const ry = tx * Math.sin(rad) + ty * Math.cos(rad);

  return { lx: rx, ly: ry };
}

/* ------------------------------------------------------------------
   SELECT / DESELECT
------------------------------------------------------------------ */

/**
 * If we are not resizing or rotating, the user might be selecting
 * or marquee-selecting or creating a shape. This is the pointerDown logic for that.
 */
export function onPointerDownSelectOrCreate(e, canvas) {
  const tool = getCurrentTool();
  // We first see if the user is clicking on an element for selection
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const wx = state.camX + sx / state.scale;
  const wy = state.camY + sy / state.scale;

  if (tool === "select") {
    // find topmost element
    const clicked = findTopmostElementAt(wx, wy);
    if (clicked) {
      if (clicked.lockedBy && clicked.lockedBy !== state.localUserId) return;
      if (e.shiftKey) {
        // toggle select
        if (state.selectedElementIds.includes(clicked.id)) {
          sendDeselectElement([clicked.id]);
          state.selectedElementIds = state.selectedElementIds.filter(
            (id) => id !== clicked.id,
          );
          delete state.lockedOffsets[clicked.id];
        } else {
          sendGrabElement(clicked.id);
          state.selectedElementIds.push(clicked.id);
        }
      } else {
        // select single
        if (!state.selectedElementIds.includes(clicked.id)) {
          sendDeselectElement(state.selectedElementIds);
          state.selectedElementIds = [];
          sendGrabElement(clicked.id);
          state.selectedElementIds.push(clicked.id);
        }
      }
      // Prepare for dragging
      for (const id of state.selectedElementIds) {
        const el = state.elements.find((ele) => ele.id === id);
        if (el?.lockedBy === state.localUserId) {
          state.lockedOffsets[id] = {
            dx: wx - el.x,
            dy: wy - el.y,
          };
        }
      }
      state.isDragging = true;
      canvas.classList.add("grabbing");
      // Update the oriented bounding box
      updateSelectionOrientedBox();
    } else {
      // Start marquee
      state.isMarqueeSelecting = true;
      state.isDragging = false;
      canvas.classList.add("grabbing");

      state.marqueeStart.xCanvas = sx * window.devicePixelRatio;
      state.marqueeStart.yCanvas = sy * window.devicePixelRatio;
      state.marqueeEnd.xCanvas = state.marqueeStart.xCanvas;
      state.marqueeEnd.yCanvas = state.marqueeStart.yCanvas;

      state.marqueeStart.xWorld = wx;
      state.marqueeStart.yWorld = wy;
      state.marqueeEnd.xWorld = wx;
      state.marqueeEnd.yWorld = wy;

      if (!e.shiftKey) {
        deselectAll();
      }
    }
  } else {
    // shape creation
    startShapeCreation(tool, wx, wy);
  }
}

/**
 * PointerMove logic when not resizing. Could be dragging selected or marquee or creation.
 */
export function onPointerMoveCommon(e, canvas) {
  if (state.isDragging && e.buttons & 1) {
    doDragSelected(e, canvas);
    requestRender();
    return;
  }
  if (state.isMarqueeSelecting && e.buttons & 1) {
    updateMarquee(e, canvas);
    requestRender();
    return;
  }
  if (state.creationState?.active && e.buttons & 1) {
    updateShapeCreation(e, canvas);
    requestRender();
    return;
  }
  // if none of those, we might update hover cursor
  updateHoverCursor(e, canvas);
}

/**
 * PointerUp logic for ending drag/marquee/shape creation
 */
export function onPointerUpCommon(e, canvas) {
  if (state.isDragging && e.button === 0) {
    state.isDragging = false;
    canvas.classList.remove("grabbing");
    for (const k of Object.keys(state.lockedOffsets)) {
      delete state.lockedOffsets[k];
    }
  }
  if (state.creationState?.active && e.button === 0) {
    finalizeShapeCreation();
  }
  if (state.isMarqueeSelecting && e.button === 0) {
    finalizeMarquee(e, canvas);
  }
}

/**
 * Cancel or Leave pointer => cleanup
 */
export function onPointerCancelOrLeaveCommon(e) {
  // if resizing, we end that above
  if (state.isDragging) {
    state.isDragging = false;
    for (const k of Object.keys(state.lockedOffsets)) {
      delete state.lockedOffsets[k];
    }
  }
}

/* ------------------------------------------------------------------
   RESIZING (ORIENTED)
------------------------------------------------------------------ */

export function startResizing(handleName, e, canvas) {
  if (handleName === "rotate-handle") {
    // It's a rotation handle => start rotating
    startRotating(e, canvas);
    return;
  }

  state.isResizing = true;
  state.activeHandle = handleName;

  // We store a snapshot of boundingBoxAtDragStart in local coords
  state.boundingBoxAtDragStart = { ...state.selectionBounds };

  // Also store shape snapshot for each selected element
  state.shapesSnapshot = [];
  for (const id of state.selectedElementIds) {
    const el = state.elements.find((x) => x.id === id);
    if (!el) continue;
    // store original x,y,w,h
    state.shapesSnapshot.push({
      id: el.id,
      x: el.x,
      y: el.y,
      w: el.w,
      h: el.h,
    });
  }
}

/**
 * Called on pointer move while resizing. We compute a scale in local coords,
 * then apply it to each shape's position + size around the selectionCenter.
 */
export function updateResizing(e, canvas) {
  if (!state.isResizing) return;
  const { x, y, w, h } = state.boundingBoxAtDragStart;
  if (w === 0 || h === 0) return;

  const { lx, ly } = getLocalPointer(e, canvas);

  // We'll define new local bounding box => new boundingBoxInLocal
  let newLeft = x;
  let newRight = x + w;
  let newTop = y;
  let newBottom = y + h;

  const handle = state.activeHandle;
  // We do not clamp below 1 in local coords, but let's keep a minimum to avoid negative or zero scale
  const minDim = 1 / state.scale;

  if (handle.includes("left")) {
    newLeft = lx;
    if (newLeft > newRight - minDim) {
      newLeft = newRight - minDim;
    }
  }
  if (handle.includes("right")) {
    newRight = lx;
    if (newRight < newLeft + minDim) {
      newRight = newLeft + minDim;
    }
  }
  if (handle.includes("top")) {
    newTop = ly;
    if (newTop > newBottom - minDim) {
      newTop = newBottom - minDim;
    }
  }
  if (handle.includes("bottom")) {
    newBottom = ly;
    if (newBottom < newTop + minDim) {
      newBottom = newTop + minDim;
    }
  }

  let finalW = newRight - newLeft;
  let finalH = newBottom - newTop;

  // SHIFT => preserve aspect ratio if corner handle
  if (
    state.shiftDown &&
    (handle === "top-left" ||
      handle === "top-right" ||
      handle === "bottom-left" ||
      handle === "bottom-right")
  ) {
    const originalRatio = w / h;
    const newRatio = finalW / finalH;
    if (Math.abs(newRatio - originalRatio) > 0.001) {
      // preserve ratio
      if (finalW / finalH > originalRatio) {
        // match width => scale height
        finalH = finalW / originalRatio;
        if (handle.includes("top")) {
          newTop = newBottom - finalH;
        } else {
          newBottom = newTop + finalH;
        }
      } else {
        // match height => scale width
        finalW = finalH * originalRatio;
        if (handle.includes("left")) {
          newLeft = newRight - finalW;
        } else {
          newRight = newLeft + finalW;
        }
      }
    }
  }

  // Now we have new local bounding box => (newLeft, newTop) to (newRight, newBottom).
  // Compute scaleX, scaleY
  const scaleX = finalW / w;
  const scaleY = finalH / h;

  // Update each shape's position + size in world coords
  // The transform is: translate shape center to selectionCenter, rotate by selectionAngle,
  // then scale, rotate back, etc. We'll do it by "inverse" approach:
  // Each shape is initially at snapshot x,y,w,h. We'll transform corners carefully.
  for (const snap of state.shapesSnapshot) {
    const el = state.elements.find((ee) => ee.id === snap.id);
    if (!el) continue;
    if (el.lockedBy !== state.localUserId && !el.lockedBy) {
      // auto-lock if not locked
      el.lockedBy = state.localUserId;
    }
    if (el.lockedBy !== state.localUserId) {
      // can't modify if locked by someone else
      continue;
    }

    // We'll treat the shape's corners in local group space and see how they'd move
    // from boundingBoxAtDragStart to new bounding box. But simpler: We do a transform
    // that goes from (cx,cy) => shift => scale => shift back.

    // The shape's center in world coords:
    const shapeCX = snap.x + snap.w / 2;
    const shapeCY = snap.y + snap.h / 2;

    // Convert to local bounding box coords => subtract selectionCenter, rotate by -selectionAngle
    const rad = (-state.selectionAngle * Math.PI) / 180;
    let tx = shapeCX - state.selectionCenter.x;
    let ty = shapeCY - state.selectionCenter.y;
    // rotate
    let rx = tx * Math.cos(rad) - ty * Math.sin(rad);
    let ry = tx * Math.sin(rad) + ty * Math.cos(rad);

    // Now we see where that local center is relative to boundingBoxAtDragStart
    // boundingBoxAtDragStart.x,y is the top-left corner in local coords
    rx -= x;
    ry -= y;

    // Apply the scale
    rx *= scaleX;
    ry *= scaleY;

    // Put it back in local coords
    rx += newLeft;
    ry += newTop;

    // Then rotate by +selectionAngle, translate by selectionCenter
    const rad2 = (state.selectionAngle * Math.PI) / 180;
    let fx = rx * Math.cos(rad2) - ry * Math.sin(rad2);
    let fy = rx * Math.sin(rad2) + ry * Math.cos(rad2);
    fx += state.selectionCenter.x;
    fy += state.selectionCenter.y;

    // That is the new shape center in world coords. The shape's size also changes
    const newW = Math.max(1, Math.round(snap.w * scaleX));
    const newH = Math.max(1, Math.round(snap.h * scaleY));
    // For bounding box resizing, we do not alter shape.angle. The shape rotates as a group.

    // So we must shift the shape's top-left to keep the center at (fx, fy).
    el.x = Math.round(fx - newW / 2);
    el.y = Math.round(fy - newH / 2);
    el.w = newW;
    el.h = newH;

    sendResizeElement(el.id, el.x, el.y, el.w, el.h);
  }
}

/**
 * End resizing => finalize with server
 */
export function endResizing(forceCancel) {
  if (state.isResizing) {
    state.isResizing = false;
    state.activeHandle = null;
    state.shapesSnapshot = [];
    if (!forceCancel && state.selectedElementIds.length) {
      sendElementResizeEnd(state.selectedElementIds);
    }
  }
}

/* ------------------------------------------------------------------
   ROTATION (ORIENTED)
------------------------------------------------------------------ */

export function startRotating(e, canvas) {
  state.isRotating = true;
  state.rotationSnapshot = [];

  // Our "group" angle is in state.selectionAngle
  // We store that as the group angle snapshot
  state.rotationCenter = { ...state.selectionCenter };
  // We also store shape angles so we can offset them accordingly
  const selEls = state.elements.filter((el) =>
    state.selectedElementIds.includes(el.id),
  );
  for (const el of selEls) {
    if (el.lockedBy === state.localUserId || !el.lockedBy) {
      // auto-lock if not locked
      if (!el.lockedBy) {
        el.lockedBy = state.localUserId;
      }
      state.rotationSnapshot.push({
        id: el.id,
        angle: el.angle || 0,
      });
    }
  }
  // pointerAngle from center
  const { pointerAngle } = pointerAngleFromCenter(
    e,
    canvas,
    state.rotationCenter,
  );
  state.rotationPointerStart = pointerAngle;
  // store the initial group angle as well
  state.selectionAngleSnapshot = state.selectionAngle;
  canvas.classList.add("grabbing");
}

/**
 * Called on pointerMove while rotating
 */
export function updateRotating(e, canvas) {
  if (!state.isRotating) return;
  const { pointerAngle } = pointerAngleFromCenter(
    e,
    canvas,
    state.rotationCenter,
  );

  let delta = pointerAngle - state.rotationPointerStart;

  // SHIFT => snap to 15 deg increments
  if (state.shiftDown) {
    const degrees = (delta * 180) / Math.PI;
    const snapped = Math.round(degrees / 15) * 15;
    delta = (snapped * Math.PI) / 180;
  }

  // This delta applies to the entire group
  const deltaDeg = (delta * 180) / Math.PI;
  const newGroupAngle = state.selectionAngleSnapshot + deltaDeg;
  // unify angle
  const finalGroupAngle = normalizeAngle(newGroupAngle);
  state.selectionAngle = finalGroupAngle;

  // now update each shape's angle => shapeAngleOffsets + groupAngle
  for (const snap of state.rotationSnapshot) {
    const el = state.elements.find((x) => x.id === snap.id);
    if (!el) continue;
    if (el.lockedBy !== state.localUserId) {
      continue;
    }
    // shape angle = original angle + deltaDeg
    let newAngle = snap.angle + deltaDeg;
    newAngle = normalizeAngle(newAngle);
    el.angle = newAngle;
    sendElementRotate(el.id, newAngle);
  }
}

/**
 * End rotating => finalize with server
 */
export function endRotating(forceCancel) {
  if (!state.isRotating) return;
  state.isRotating = false;
  if (!forceCancel && state.selectedElementIds.length) {
    sendWSMessage({
      type: MESSAGE_TYPES.ELEMENT_ROTATE_END,
      userId: state.localUserId,
      elementIds: state.selectedElementIds,
    });
  }
  state.rotationSnapshot = [];
  state.rotationCenter = null;
  state.rotationPointerStart = 0;
  state.selectionAngleSnapshot = 0;

  // We also update the oriented bounding box after rotation
  updateSelectionOrientedBox();
}

/**
 * Helper: compute pointer angle relative to the rotationCenter (in world coords).
 */
function pointerAngleFromCenter(e, canvas, center) {
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const wx = state.camX + sx / state.scale;
  const wy = state.camY + sy / state.scale;

  const dx = wx - center.x;
  const dy = wy - center.y;
  const pointerAngle = Math.atan2(dy, dx);
  return { pointerAngle };
}

/* ------------------------------------------------------------------
   DRAG SELECTED
------------------------------------------------------------------ */

export function doDragSelected(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const wx = state.camX + sx / state.scale;
  const wy = state.camY + sy / state.scale;

  for (const id of state.selectedElementIds) {
    const el = state.elements.find((ele) => ele.id === id);
    if (el?.lockedBy === state.localUserId) {
      const off = state.lockedOffsets[id];
      if (off) {
        const nx = wx - off.dx;
        const ny = wy - off.dy;
        sendMoveElement(id, nx, ny);
      }
    }
  }
}

/* ------------------------------------------------------------------
   MARQUEE
------------------------------------------------------------------ */

function updateMarquee(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  state.marqueeEnd.xCanvas = (e.clientX - rect.left) * window.devicePixelRatio;
  state.marqueeEnd.yCanvas = (e.clientY - rect.top) * window.devicePixelRatio;

  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  state.marqueeEnd.xWorld = state.camX + sx / state.scale;
  state.marqueeEnd.yWorld = state.camY + sy / state.scale;
}

function finalizeMarquee(e, canvas) {
  state.isMarqueeSelecting = false;
  canvas.classList.remove("grabbing");

  const rminX = Math.min(state.marqueeStart.xWorld, state.marqueeEnd.xWorld);
  const rmaxX = Math.max(state.marqueeStart.xWorld, state.marqueeEnd.xWorld);
  const rminY = Math.min(state.marqueeStart.yWorld, state.marqueeEnd.yWorld);
  const rmaxY = Math.max(state.marqueeStart.yWorld, state.marqueeEnd.yWorld);

  const newlySelected = [];
  for (const el of state.elements) {
    if (el.lockedBy && el.lockedBy !== state.localUserId) continue;
    const corners = getWorldSpaceShapeCorners(el);
    // If corners are within the marquee (approx), we consider it selected if
    // any corner is inside, or the bounding box overlaps
    let cminX = Infinity,
      cminY = Infinity,
      cmaxX = -Infinity,
      cmaxY = -Infinity;
    for (const c of corners) {
      if (c.x < cminX) cminX = c.x;
      if (c.x > cmaxX) cmaxX = c.x;
      if (c.y < cminY) cminY = c.y;
      if (c.y > cmaxY) cmaxY = c.y;
    }
    // Overlap check
    if (boxesOverlap(rminX, rminY, rmaxX, rmaxY, cminX, cminY, cmaxX, cmaxY)) {
      newlySelected.push(el.id);
    }
  }

  if (!e.shiftKey) {
    deselectAll();
  }
  for (const id of newlySelected) {
    if (!state.selectedElementIds.includes(id)) {
      state.selectedElementIds.push(id);
      sendGrabElement(id);
    }
  }
  // Update oriented box
  updateSelectionOrientedBox();
}

/* ------------------------------------------------------------------
   SHAPE CREATION
------------------------------------------------------------------ */

function startShapeCreation(tool, wx, wy) {
  state.creationState = {
    active: true,
    tool,
    startWX: wx,
    startWY: wy,
    curWX: wx,
    curWY: wy,
  };
}

function updateShapeCreation(e, canvas) {
  if (!state.creationState?.active) return;
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const wx = state.camX + sx / state.scale;
  const wy = state.camY + sy / state.scale;

  state.creationState.curWX = wx;
  state.creationState.curWY = wy;
}

function finalizeShapeCreation() {
  if (!state.creationState) return;
  const { tool, startWX, startWY, curWX, curWY } = state.creationState;
  state.creationState.active = false;

  let x = Math.min(startWX, curWX);
  let y = Math.min(startWY, curWY);
  let w = Math.abs(curWX - startWX);
  let h = Math.abs(curWY - startWY);

  if (state.shiftDown && (tool === "rectangle" || tool === "ellipse")) {
    const side = Math.max(w, h);
    w = side;
    h = side;
  }
  if (tool === "text") {
    // default text height
    h = 30;
  }
  if (w < 2 && h < 2) return;

  x = Math.round(x);
  y = Math.round(y);
  w = Math.round(w);
  h = Math.round(h);

  deselectAll();
  sendElementCreate(tool, x, y, w, h);
  revertToSelectTool();
}

/* ------------------------------------------------------------------
   HOVER CURSOR
------------------------------------------------------------------ */

function updateHoverCursor(e, canvas) {
  if (
    !state.isPanning &&
    !state.isResizing &&
    !state.isDragging &&
    !state.isRotating
  ) {
    const tool = getCurrentTool();
    if (tool === "select" && canTransformSelection()) {
      // check oriented handles
      const handle = hitTestOrientedResizeHandles(e, canvas);
      if (handle) {
        if (handle === "rotate-handle") {
          canvas.style.cursor = "grab";
          return;
        }
        canvas.style.cursor = getCursorForHandle(handle);
        return;
      }
    }
    canvas.style.cursor = "default";
  }
}

/* ------------------------------------------------------------------
   Helpers
------------------------------------------------------------------ */

export function deselectAll() {
  if (state.selectedElementIds.length) {
    sendDeselectElement(state.selectedElementIds);
    state.selectedElementIds = [];
  }
}

function getCurrentTool() {
  const palette = document.getElementById("tools-palette");
  if (!palette) return "select";
  const btn = palette.querySelector(".tool-btn.selected");
  return btn?.dataset?.tool || "select";
}

function canTransformSelection() {
  if (!state.selectedElementIds.length) return false;
  for (const id of state.selectedElementIds) {
    const el = state.elements.find((e) => e.id === id);
    if (!el) continue;
    if (el.lockedBy && el.lockedBy !== state.localUserId) return false;
  }
  return true;
}

function findTopmostElementAt(wx, wy) {
  // We'll do approximate bounding box test in world coords ignoring rotation,
  // but for ellipse we do a more exact check
  for (let i = state.elements.length - 1; i >= 0; i--) {
    const el = state.elements[i];
    // rotate logic
    if (el.shape === "ellipse") {
      const cx = el.x + el.w / 2;
      const cy = el.y + el.h / 2;
      const rx = el.w / 2;
      const ry = el.h / 2;
      const dx = wx - cx;
      const dy = wy - cy;
      // also consider shape's angle
      if (el.angle) {
        const rad = (-el.angle * Math.PI) / 180;
        const rx2 = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry2 = dx * Math.sin(rad) + dy * Math.cos(rad);
        if ((rx2 * rx2) / (rx * rx) + (ry2 * ry2) / (ry * ry) <= 1) {
          return el;
        }
      } else {
        if ((dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1) {
          return el;
        }
      }
    } else {
      // rectangle or text: rotate test
      if (el.angle) {
        // transform pointer to shape's local coords
        const angleRad = (-el.angle * Math.PI) / 180;
        const cx = el.x + el.w / 2;
        const cy = el.y + el.h / 2;
        const dx = wx - cx;
        const dy = wy - cy;
        const rx2 = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
        const ry2 = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
        if (
          rx2 >= -el.w / 2 &&
          rx2 <= el.w / 2 &&
          ry2 >= -el.h / 2 &&
          ry2 <= el.h / 2
        ) {
          return el;
        }
      } else {
        if (
          wx >= el.x &&
          wx <= el.x + el.w &&
          wy >= el.y &&
          wy <= el.y + el.h
        ) {
          return el;
        }
      }
    }
  }
  return null;
}

function getCursorForHandle(handle) {
  switch (handle) {
    case "top-left":
    case "bottom-right":
      return "nwse-resize";
    case "top-right":
    case "bottom-left":
      return "nesw-resize";
    case "top":
    case "bottom":
      return "ns-resize";
    case "left":
    case "right":
      return "ew-resize";
    case "rotate-handle":
      return "grab";
    default:
      return "default";
  }
}

/* ------------------------------------------------------------------
   SEND MESSAGES
------------------------------------------------------------------ */

function sendGrabElement(elementId) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_GRAB,
    userId: state.localUserId,
    elementId,
  });
}

function sendMoveElement(elementId, x, y) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_MOVE,
    userId: state.localUserId,
    elementId,
    x,
    y,
  });
}

function sendDeselectElement(elementIds) {
  if (!elementIds?.length) return;
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_DESELECT,
    userId: state.localUserId,
    elementIds,
  });
  for (const eid of elementIds) {
    delete state.lockedOffsets[eid];
  }
}

function sendElementCreate(shape, x, y, w, h) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_CREATE,
    userId: state.localUserId,
    shape,
    x,
    y,
    w,
    h,
  });
}

function sendResizeElement(elementId, x, y, w, h) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_RESIZE,
    userId: state.localUserId,
    elementId,
    x,
    y,
    w,
    h,
  });
}

function sendElementResizeEnd(ids) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_RESIZE_END,
    userId: state.localUserId,
    elementIds: ids,
  });
}

function sendElementRotate(elementId, angle) {
  sendWSMessage({
    type: MESSAGE_TYPES.ELEMENT_ROTATE,
    userId: state.localUserId,
    elementId,
    angle,
  });
}

function revertToSelectTool() {
  const palette = document.getElementById("tools-palette");
  if (!palette) return;
  const buttons = palette.querySelectorAll(".tool-btn");
  buttons.forEach((b) => {
    b.classList.remove("selected");
    if (b.dataset.tool === "select") {
      b.classList.add("selected");
    }
  });
}

export function createOrUpdateElementsFromServer(serverElements) {
  state.elements = serverElements || [];
}

export function removeObsoleteSelections(myUserId) {
  state.selectedElementIds = state.selectedElementIds.filter((id) => {
    const el = state.elements.find((e) => e.id === id);
    if (!el) return false;
    if (el.lockedBy && el.lockedBy !== myUserId) return false;
    return true;
  });
  for (const k of Object.keys(state.lockedOffsets)) {
    if (!state.selectedElementIds.includes(+k)) {
      delete state.lockedOffsets[k];
    }
  }
}

export function handleCursorData(data, myUserId) {
  if (data.type === MESSAGE_TYPES.CURSOR_UPDATE) {
    if (data.userId !== myUserId) {
      state.remoteCursors.set(data.userId, { x: data.x, y: data.y });
    }
  } else if (data.type === MESSAGE_TYPES.CURSOR_UPDATES) {
    for (const [uId, pos] of Object.entries(data.cursors)) {
      state.remoteCursors.set(uId, pos);
    }
    for (const oldId of state.remoteCursors.keys()) {
      if (!data.cursors[oldId]) {
        state.remoteCursors.delete(oldId);
      }
    }
  }
}

export function removeStaleRemoteCursors(currentUserIds) {
  for (const [uId] of state.remoteCursors) {
    if (!currentUserIds.includes(uId)) {
      state.remoteCursors.delete(uId);
    }
  }
}

export function setLocalUserId(newId) {
  state.localUserId = newId;
}


===== ./db-init-scripts/init.sql =====

-- db-init-scripts/init.sql

-- 1) Create main DB
CREATE DATABASE board_game_prototyping;
\connect board_game_prototyping;

-- Create tables in main DB
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(150) UNIQUE NOT NULL,
  password VARCHAR(200) NOT NULL,
  role VARCHAR(50) DEFAULT 'user'
);

CREATE TABLE projects (
  id SERIAL PRIMARY KEY,
  owner_id INT REFERENCES users(id),
  name VARCHAR(200),
  description TEXT
);

CREATE TABLE project_versions (
  id SERIAL PRIMARY KEY,
  project_id INT REFERENCES projects(id),
  version_number INT NOT NULL,
  project_data JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW()
);

/* 
   IMPORTANT: Grant ownership & privileges in the main DB 
   so that "admin" can SELECT/INSERT/UPDATE these tables.
*/
CREATE ROLE admin WITH LOGIN PASSWORD 'test1234';
GRANT ALL PRIVILEGES ON DATABASE board_game_prototyping TO admin;

ALTER TABLE users OWNER TO admin;
ALTER TABLE projects OWNER TO admin;
ALTER TABLE project_versions OWNER TO admin;

ALTER SEQUENCE users_id_seq OWNER TO admin;
ALTER SEQUENCE projects_id_seq OWNER TO admin;
ALTER SEQUENCE project_versions_id_seq OWNER TO admin;

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin;
/* 
   Optionally ensure future tables are also covered:
   ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO admin;
*/


-- 2) Create test DB
CREATE DATABASE board_game_prototyping_test;
\connect board_game_prototyping_test;

-- Create the same tables in the test DB
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(150) UNIQUE NOT NULL,
  password VARCHAR(200) NOT NULL,
  role VARCHAR(50) DEFAULT 'user'
);

CREATE TABLE projects (
  id SERIAL PRIMARY KEY,
  owner_id INT REFERENCES users(id),
  name VARCHAR(200),
  description TEXT
);

CREATE TABLE project_versions (
  id SERIAL PRIMARY KEY,
  project_id INT REFERENCES projects(id),
  version_number INT NOT NULL,
  project_data JSONB DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW()
);

/*
   Grant ownership & privileges in the test DB for 'admin' as well.
*/
GRANT ALL PRIVILEGES ON DATABASE board_game_prototyping_test TO admin;

ALTER TABLE users OWNER TO admin;
ALTER TABLE projects OWNER TO admin;
ALTER TABLE project_versions OWNER TO admin;

ALTER SEQUENCE users_id_seq OWNER TO admin;
ALTER SEQUENCE projects_id_seq OWNER TO admin;
ALTER SEQUENCE project_versions_id_seq OWNER TO admin;

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO admin;

</file_contents>

<user_instructions>

Your task is to:

Fix the element rotation feature.

Currently the element rotates, but the associated selection overlay does not. The intended functionality is that the rotation updates along with the element as it is rotated. The collision for the different elements should remain accurate to this updated rotation for future transformations. (Such that if the element is rotated 46 degrees, the hit test for each part of the transformation controls should accurately reflect this transformed state. The transformation should also be accurate to the updated position so each side and corner should scale from its updated relative rotation. The goal is to finish the full implementation of rotation. (I also want to ensure the that the hit test mechanism is nice and generic for any future needs that want for that flexibility.) 

As a point of implementation clarification, if multiple elements are selected, please create support logic to support the rotate and transform the elements as a group using the bounding box as the reference point and the individual elements as a setting that can be specified by the user. (We will define that latter, but sit it to the group version as the default.)

Please make expertly considered and surgical changes to any files needed to support the intended functionality. Please be extremely precise in order to preserve the other functionality. I will provide the source code below for you to modify.

A successful implementation will have the rotation fully working as intended without breaking other parts of the application. Please double check your work to the best of your ability.

Return the generated code
The implementation plan is just a suggestion meant to provide a high-level overview of the objective. Use it to guide you, but you do not have to adhere to it strictly. Make sure to follow the given rules as you work along the lines of the plan.

For EVERY file you modify or create, you MUST provide the COMPLETE file contents in the format above.

Guidelines for code changes:

Do not get lazy. Always output the full code in the XML section.
Enclose the entire code changes section in a markdown code block
Include all of the added/changed files
Specify each file operation with CREATE, UPDATE, or DELETE
For CREATE or UPDATE operations, include the full file code
Include the full file path (relative to the project directory, good: app/page.tsx, bad: /Users/username/Desktop/projects/new-chat-template/app/page.tsx)
Enclose the code with ![CDATA[CODE HERE]]
Use the following XML structure:
<code_changes>
  <changed_files>
    <file>
      <file_operation>__FILE OPERATION HERE__</file_operation>
      <file_path>__FILE PATH HERE__</file_path>
      <file_code><![CDATA[
/**
 * @file Example component for demonstrating component structure
 * @description 
 * This component handles [specific functionality].
 * It is responsible for [specific responsibilities].
 * 
 * Key features:
 * - Feature 1: Description
 * - Feature 2: Description
 * 
 * @dependencies
 * - DependencyA: Used for X
 * - DependencyB: Used for Y
 * 
 * @notes
 * - Important implementation detail 1
 * - Important implementation detail 2
 */

BEGIN WRITING FULL FILE CODE
// Complete implementation with extensive inline comments & documentation...
]]></file_code>
    </file>
    **REMAINING FILES HERE**
  </changed_files>
</code_changes>
Documentation requirements:

File-level documentation explaining the purpose and scope
Component/function-level documentation detailing inputs, outputs, and behavior
Inline comments explaining complex logic or business rules
Type documentation for all interfaces and types
Notes about edge cases and error handling
Any assumptions or limitations
Guidelines:

Implement exactly one step at a time
Ensure all code follows the project rules and technical specification
Include ALL necessary imports and dependencies
Write clean, well-documented code with appropriate error handling
Always provide COMPLETE file contents - never use ellipsis (...) or placeholder comments
Never skip any sections of any file - provide the entire file every time
Handle edge cases and add input validation where appropriate
Follow TypeScript best practices and ensure type safety
Include necessary tests as specified in the testing strategy
Begin by identifying the next incomplete step from the plan, then generate the required code (with complete file contents and documentation) and return the full XML code block.

Above each file, include a "Here's what I did and why" explanation of what you did for that file.

Then end with "STEP X COMPLETE. Here's what I did and why:" followed by an explanation of what you did and then a "USER INSTRUCTIONS: Please do the following:" followed by manual instructions for the user for things you can't do like installing libraries, updating configurations on services, etc.

You also have permission to update the implementation plan if needed. If you update the implementation plan, include each modified step in full and return them as markdown code blocks at the end of the user instructions. No need to mark the current step as complete - that is implied.